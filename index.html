<!DOCTYPE html>
<html>
<head>
    <title>Llemmings</title>
    <style type="text/css">
        canvas {
            border: 1px solid black;
            image-rendering: pixelated; 
        }
        button {
          font-size: 40px;
        }

        /* >>> Prompt: css.0001.txt */
        body {
          font-family: Arial, sans-serif;
          background-color: #000;
          color: #f0f0f0;
          margin: 0;
          padding: 0;
          height: 100vh; /* set the height to 100% of the viewport height */
        }

        header {
            background-color: black;
            color: #F0F0F0;
            padding: 10px;
            text-align: center;
        }

        p {
            font-size: 16px;
            margin-top: 0;
        }

        a {
            color: #F0F0F0;
            text-decoration: none;
        }

        a:hover {
            color: grey;
        }
        
        /* >>> Prompt: instructions/css.0001.txt prompt 2 */
        #coordinatesDiv {
          position: fixed;
          bottom: 0;
          left: 0;
        }
    </style>
</head>
<body>

<!-- >>> Prompt: instructions/about.0001.txt -->
<header>
    <p>What is this? <a href="https://github.com/romland/llemmings">See Github</a>.</p>
</header>

  <canvas id="canvas" width="800" height="600"></canvas>
  <div id="coordinatesDiv"></div>


<script type="text/javascript">
// HUMAN: cheat, I needed a seedable RNG
function RNG(seed) {
    var m = 2**35 - 31
    var a = 185852
    var s = seed % m
    return function () {
        return (s = s * a % m) / m
    }
}

// const currentSeed = Date.now();   // "random"
const currentSeed = 1680878681505;

console.log("Current seed: ", currentSeed);
Math.random = RNG(currentSeed);

const waterColorBytes = [0x00, 0x77, 0xbe]; // [0, 119, 190];
const rockColorBytes  = [0x88, 0x88, 0x88]; // [136, 136, 136];
const dirtColorBytes  = [0x4a, 0x2e, 0x00]; // [74, 46, 0];
const terrainColorBytes = [ rockColorBytes, dirtColorBytes ];

const canvas = document.querySelector('canvas');
canvas.width = 800;
canvas.height = 600;
const ctx = canvas.getContext('2d', { willReadFrequently: true });  // HUMAN: Added this due to Chrome suggesting it
let background; // global variable to store canvas image data (restored in main loop below somewhere)
function getBackground() {
  background = ctx.getImageData(0, 0, canvas.width, canvas.height);
}

// >>> Prompt: instructions/map-generation.0003.txt (0001-0002 are now obsolete)
const WATER_HEIGHT = 70;
const EMPTY_SPACE_TOP_LEFT = 50;
const EMPTY_SPACE_BOTTOM_RIGHT = 50;

const emptyColorBytes = [ 0, 0, 0];
// const waterColorBytes = [0x00, 0x77, 0xbe]; // [0, 119, 190];
// const rockColorBytes  = [0x88, 0x88, 0x88]; // [136, 136, 136];
// const dirtColorBytes  = [0x4a, 0x2e, 0x00]; // [74, 46, 0];

const TILE_SIZE = 1;

// NOISE SETTINGS
const OCTAVES = 5;
const PERSISTENCE = 0.5;
const LACUNARITY = 2.25;
const AMPLITUDE = 2.0;
// let canvas;

function generateMap(canvasWidth, canvasHeight, emptySpaceTopLeft, emptySpaceBottomRight) {

    // create empty map
    const map = [];
    for (let y = 0; y < canvasHeight; y++) {
        map[y] = [];
        for (let x = 0; x < canvasWidth; x++) {
            map[y][x] = 0;
        }
    }

    // create height map using Perlin noise
    for (let y = 0; y < canvasHeight; y++) {
        for (let x = 0; x < canvasWidth; x++) {
            let amplitude = AMPLITUDE;
            let frequency = 1.0 / canvasWidth;
            let noiseHeight = 0;

            for (let i = 0; i < OCTAVES; i++) {
                let sampleX = x * frequency;
                let sampleY = y * frequency;
                let noiseValue = PerlinNoise2D(sampleX, sampleY);
                noiseHeight += noiseValue * amplitude;

                amplitude *= PERSISTENCE;
                frequency *= LACUNARITY;
            }

            map[y][x] = noiseHeight;
        }
    }

    // ====================== tunnels ======================
    // constants for tunnel/cave generation
    const TUNNEL_SIZE = 40;
    const TUNNEL_MIN_LENGTH = 150;
    const TUNNEL_MAX_LENGTH = 400;

    // carve out tunnels
    for (let y = 0; y < canvasHeight; y += TUNNEL_SIZE) {
    let x = 0;
    while (x < canvasWidth - TUNNEL_SIZE) {
        if(Math.random() < 0.8) {
        break;
        }

        if (map[y][x] > 0.4) {
        const tunnelLength = Math.floor(Math.random() * (TUNNEL_MAX_LENGTH - TUNNEL_MIN_LENGTH + 1)) + TUNNEL_MIN_LENGTH;
        let curve = Math.floor(Math.random() * TUNNEL_SIZE) - TUNNEL_SIZE / 2;
        for (let i = 0; i < tunnelLength && x < canvasWidth - TUNNEL_SIZE; i++) {
            const startY = Math.max(0, y + curve);
            const endY = Math.min(canvasHeight, y + TUNNEL_SIZE + curve);
            for (let j = startY; j < endY; j++) {
            if (map[j][x] > 0.4) {
                map[j][x] = 0;
            }
            }
            x++;
            curve += Math.floor(Math.random() * 3) - 1;
            curve = Math.max(-TUNNEL_SIZE / 2, Math.min(curve, TUNNEL_SIZE / 2));
        }
        }
        else {
        x++;
        }
    }
    }

    for (let x = 0; x < canvasWidth; x += TUNNEL_SIZE) {
    let y = 0;
    while (y < canvasHeight - TUNNEL_SIZE) {
        if(Math.random() < 0.8) {
            break;
        }

        if (map[y][x] > 0.4) {
        const tunnelLength = Math.floor(Math.random() * (TUNNEL_MAX_LENGTH - TUNNEL_MIN_LENGTH + 1)) + TUNNEL_MIN_LENGTH;
        let curve = Math.floor(Math.random() * TUNNEL_SIZE) - TUNNEL_SIZE / 2;
        for (let i = 0; i < tunnelLength && y < canvasHeight - TUNNEL_SIZE; i++) {
            const startX = Math.max(0, x + curve);
            const endX = Math.min(canvasWidth, x + TUNNEL_SIZE + curve);
            for (let j = startX; j < endX; j++) {
            if (map[y][j] > 0.4) {
                map[y][j] = 0;
            }
            }
            y++;
            curve += Math.floor(Math.random() * 3) - 1;
            curve = Math.max(-TUNNEL_SIZE / 2, Math.min(curve, TUNNEL_SIZE / 2));
        }
        }
        else {
        y++;
        }
    }
    }
    // ====================== /tunnels ======================

    const ctx = canvas.getContext('2d');

    for (let y = 0; y < canvasHeight; y += TILE_SIZE) {
        for (let x = 0; x < canvasWidth; x += TILE_SIZE) {
            const height = map[y][x];
            let color;

            if (height >= 0.7) {
                // rock
                color = rockColorBytes;
            } else if (height >= 0.4) {
                // dirt
                color = dirtColorBytes;
            } else {
                // background
                color = emptyColorBytes;
            }

            ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
            ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
        }
    }

    // add empty space at top left and bottom right
    ctx.clearRect(0, 0, EMPTY_SPACE_TOP_LEFT, EMPTY_SPACE_TOP_LEFT);
    // HUMAN: Moved to above water level.
    ctx.clearRect(canvasWidth - EMPTY_SPACE_BOTTOM_RIGHT, canvasHeight - WATER_HEIGHT - EMPTY_SPACE_BOTTOM_RIGHT, EMPTY_SPACE_BOTTOM_RIGHT, EMPTY_SPACE_BOTTOM_RIGHT);

    // water
    ctx.fillStyle = `rgb(${waterColorBytes[0]}, ${waterColorBytes[1]}, ${waterColorBytes[2]})`;
    ctx.fillRect(0, canvasHeight - WATER_HEIGHT, canvasWidth, WATER_HEIGHT);
}

function PerlinNoise2D(x, y) {
    const xInt = Math.floor(x);
    const yInt = Math.floor(y);

    const X = xInt & 255;
    const Y = yInt & 255;

    x -= xInt;
    y -= yInt;

    const u = fade(x);
    const v = fade(y);

    const A = noiseHash[X] + Y;
    const AA = noiseHash[A];
    const AB = noiseHash[A + 1];
    const B = noiseHash[X + 1] + Y;
    const BA = noiseHash[B];
    const BB = noiseHash[B + 1];

    return lerp(v, lerp(u, grad(noiseHash[AA], x, y), grad(noiseHash[BA], x - 1, y)),
                   lerp(u, grad(noiseHash[AB], x, y - 1), grad(noiseHash[BB], x - 1, y - 1)));
}

function fade(t) {
    return t * t * t * (t * (t * 6 - 15) + 10);
}

function lerp(t, a, b) {
    return a + t * (b - a);
}

function grad(hash, x, y) {
    const h = hash & 3;
    const u = h === 0 ? x : h === 1 ? y : x + y;
    const v = h < 2 ? y : x;
    return ((hash & 4) === 0 ? 1 : -1) * u + ((hash & 8) === 0 ? 1 : -1) * v;
}

const noiseHash = [];
for (let i = 0; i < 256; i++) {
    noiseHash[i] = Math.floor(Math.random() * 256);
}

// canvas = document.querySelector('canvas');
// canvas.width = 800;
// canvas.height = 600;
generateMap(canvas.width, canvas.height, EMPTY_SPACE_TOP_LEFT, EMPTY_SPACE_BOTTOM_RIGHT);

// =============================================

// console.log("Unique colors:", getUniqueColors(canvas));


// >>> Prompt: Sadly I forgot to save the prompt for generating the "textures". :/
noiseScale = 0.05; // controls zoom level
const numOctaves = 4;
const persistence = 0.5; // controls roughness
const width = canvas.width;
const height = canvas.height;

// Create a blank image to draw onto (HUMAN: actually, copy existing image ...)
let oldImgData = ctx.getImageData(0,0,width,height);    // TODO: This should be renamed, but I don't want to do it now since it would make some prompts invalid (for demonstration purposes). It does nicely illustrate the example of the need to keep track of these things.
let canvasBytes = Uint8ClampedArray.from(oldImgData.data);
const imgData = new ImageData(canvasBytes, width, height);

// Render "texture" (or not)
if(false) {
    // Loop over each pixel in the image
    for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
        const pixelOffset = ((y * width) + x) * 4; // x2 for RGBA channels

        const isRock = pixelIsColor(imgData, x, y, [0x88, 0x88, 0x88, 255]);
        const isDirt = pixelIsColor(imgData, x, y, [0x4a, 0x2e, 0x00, 255]);

        if(!isRock && !isDirt) {
            // console.log("skipping");
            continue;
        }


        // Calculate value of noise at this pixel
        let noiseValue = 0;
        for (let octave = 1; octave <= numOctaves; octave++) {
        const frequency = Math.pow(2, octave);
        const amplitude = Math.pow(persistence, octave);
        noiseValue += noiseGenerator.noise(x * noiseScale * frequency,
                                            y * noiseScale * frequency,
                                            0) * amplitude;
        }
        noiseValue = (noiseValue * 0.5) + 0.5; // normalise between 0 and 1

        // Use noise value to determine pixel color
        let r, g, b;
        if (isRock) { // rock color
        const shade = noiseValue + (Math.random() * 0.2);
        r = shade * 90;
        g = shade * 90;
        b = shade * 90;
        } else { // dirt color
        const shade = noiseValue + (Math.random() * 0.2) - 0.4;
        r = shade * 120;
        g = shade * 100;
        b = shade * 80;
        }

        // Set the pixel color in the image data buffer
        imgData.data[pixelOffset] = r;   // Red channel
        imgData.data[pixelOffset+1] = g; // Green channel
        imgData.data[pixelOffset+2] = b; // Blue channel
        imgData.data[pixelOffset+3] = 255; // Alpha channel (255 for opaque)
    }
    }

    // Draw final image to canvas
    ctx.putImageData(imgData, 0, 0);

}



const blueBox = [0x00, 0x00, 0xff];
const greenBox = [0x00, 0xff, 0x00];
const GRAVITY = 0.03; // Adjust this until falling looks good
const lemmings = [];

const VEL_CLIMB = 1;    // Cheat. HUMAN added this undeclared variable.

let lastLemmingId = 0;

// ============== lemming sprite
// >>> Prompt: instructions/movement-collisions.0001.txt
// >>> Prompt: instructions/movement-collisions.0002.txt
// >>> Prompt: instructions/movement-collisions.0003.txt
// >>> Prompt: instructions/lemming.update.0001.txt
// >>> Prompt: instructions/lemming.update.0002.txt
class Lemming {
  constructor(x, y) {
    this.id = -49152;
    this.age = 0;
    this.width = 10;
    this.height = 20;
    this.maxVelX = 0.2;
    this.deadlyVelY = 3;
    this.x = x;
    this.y = y;
    this.velX = 0;
    this.velY = 0;
    this.isSelected = false;
    this.onGround = false;
    this.isClimbing = false;
    this.isDead = false;
    this.action = null;
    this.actionStarted = false;

    // Initialize these variables in the constructor or wherever appropriate
    this.legColor = "green";
    this.footColor = "#888888";
    this.legAngle = 0;
    this.legWidth = this.width * 0.4;
    this.legHeight = this.height * 0.35;
    this.footWidth = this.legWidth * 1.8;
    this.footHeight = this.legHeight * 0.4;
  }

  // >>> Prompt: instructions/lemming-legs.draw.0001.txt
  draw() {
    // draw body
    ctx.fillStyle = "rgb(" + blueBox.join(",") + ")";
    ctx.fillRect(this.x, this.y, this.width, this.height * 0.75);

    // calculate leg positions based on velocity and direction
    let leftLegX, leftFootX, rightLegX, rightFootX;
    if (this.velX > 0) {
      this.legAngle = Math.sin(this.age / 11) * Math.PI / 4;
      leftLegX = this.x + this.width * 0.1;
      leftFootX = -(this.legWidth/2);
      rightLegX = this.x + this.width * 0.5;
      rightFootX = -(this.legWidth/2);
    } else if (this.velX < 0) {
      this.legAngle = -Math.sin(this.age / 11) * Math.PI / 4;
      leftLegX = this.x + this.width * 0.5;
      leftFootX = -this.legWidth ;
      rightLegX = this.x + this.width * 0.9 - this.legWidth;
      rightFootX = -this.legWidth ;
    } else {
      this.legAngle = 0;
      leftLegX = this.x + this.width * 0.1;
      leftFootX = -this.legWidth;
      rightLegX = this.x + this.width * 0.9 - this.legWidth;
      rightFootX = -this.legWidth;
    }

    ctx.fillStyle = this.legColor;
    ctx.save();
    // left leg
    ctx.translate(leftLegX + this.legWidth / 2, this.y + this.height * 0.75);
    ctx.rotate(this.legAngle);
    ctx.fillRect(-this.legWidth / 2, 0, this.legWidth, this.legHeight);

    // left foot
    ctx.fillStyle = this.footColor;
    ctx.fillRect(leftFootX, this.legHeight - this.footHeight, this.footWidth, this.footHeight);
    ctx.restore();

    ctx.save();
    // right leg
    ctx.translate(rightLegX + this.legWidth / 2, this.y + this.height * 0.75)
    ctx.rotate(-this.legAngle);
    ctx.fillRect(-this.legWidth / 2, 0, this.legWidth, this.legHeight);

    // right foot
    ctx.fillStyle = this.footColor;
    ctx.fillRect(rightFootX, this.legHeight - this.footHeight, this.footWidth, this.footHeight);
    ctx.restore();

    // hair
    ctx.fillStyle = "rgb(" + greenBox.join(",") + ")";
    ctx.fillRect(this.x, this.y, this.width, this.height / 4);

    // is selected
    if (this.isSelected) {
      ctx.strokeStyle = "red";
      ctx.strokeRect(this.x, this.y, this.width, this.height);
    }

    // debug
    ctx.strokeStyle = "white";
    ctx.strokeText(this.id, this.x + 1, this.y + 13);
    if (this.action) {
      ctx.font = "7px Arial";
      ctx.strokeText(this.action, this.x - 5, this.y - 5);
    }
  }

  update() {
    if (this.y >= canvas.height - (this.height + this.velY + 1)) {
        this.isDead = true;
        return;
    }

    // Check if ground is under us or not
    let isGroundUnderneath = isPixelOneOf(oldImgData, this.x + this.width / 2, this.y + this.height + 1, terrainColorBytes);

    let heightAdjustment = 0;

    if (isGroundUnderneath) {
        heightAdjustment = 0;
        for(let i = 0; i < 6; i++) {
          if(isPixelOneOf(oldImgData, this.x + this.width / 2, this.y + this.height - i, terrainColorBytes)) {
            heightAdjustment--;
          } else {
            break;
          }
        }
    }

    // Check if we hit a wall on the x axis
    // >>> Prompt: instructions/wall-hit-fix.0001.txt
    const hitWallOnLeft = this.velX < 0 && isPixelOneOf(oldImgData, this.x - 1, this.y + this.height / 2, terrainColorBytes);
    const hitWallOnRight = this.velX > 0 && isPixelOneOf(oldImgData, this.x + this.width + 1, this.y + this.height / 2, terrainColorBytes);

    // Check if we've fallen in water
    const isWaterBelow = pixelIsColor(oldImgData, this.x + this.width / 2, this.y + this.height + 1, waterColorBytes);

    // Determine if the lemming should climb
    let shouldClimb = false;

    if (this.action === "Climber") {
        if ((hitWallOnLeft && this.velX < 0) || (hitWallOnRight && this.velX > 0)) {
            shouldClimb = true;
        } else {
            this.isClimbing = false; // Reset climbing flag
        }
    }

    // Update velocity according to the collision rules
    if (!this.onGround) {
        if (this.action === "Floater") {
            this.velY += GRAVITY * 0.1;
        } else {
            this.velY += GRAVITY;
        }

        if (isGroundUnderneath) {
            if (this.velY > this.deadlyVelY) {
                // splat
                this.isDead = true;
                return;
            }
            this.onGround = true;
            this.velY = 0;
        }
    } else if (this.onGround && !isGroundUnderneath) {
        // Start falling if there's no ground
        this.onGround = false;
    }

    // ============ Digger/Basher/Miner code
    let digging = false;

    if (this.action === "Digger" || this.action === "Miner" || this.action === "Basher") {
        digging = startDigging(this);
    }
    // ============ /Digger/Basher/Miner code

    // Check if there are other lemmings that are blockers
    for (let i = 0; i < lemmings.length; i++) {
        const otherLemming = lemmings[i];

        if (
            otherLemming !== this &&
            !otherLemming.isDead &&
            otherLemming.action === "Blocker" &&
            this.x + this.width > otherLemming.x &&
            this.x < otherLemming.x + otherLemming.width &&
            this.y + this.height > otherLemming.y &&
            this.y < otherLemming.y + otherLemming.height
        ) {
            this.velX *= -1;
        }
    }

    // Handle climbing
    if (shouldClimb) {
        this.isClimbing = true;
        let climbDirection = hitWallOnLeft ? 1 : -1;
        this.x += climbDirection * this.maxVelX;
        this.y -= 1;

        this.velY = -VEL_CLIMB*0.05; // Start going up at climbing velocity
        this.onGround = false; // We've left the ground
    } else {
        // Not climbing, normal movement applies
        // HUMAN: added check for 'this.velY === 0' here so that we don't turn when we are falling
        // HUMAN: don't turn if digging
        if (!digging && this.velY === 0 && this.action !== "Climber" && (hitWallOnLeft || hitWallOnRight || this.x <= this.width || this.x >= canvas.width - this.width)) {
            this.velX *= -1;
        }

        if (isWaterBelow || this.y >= canvas.height - this.height) {
            this.isDead = true;
        }

        // Apply height adjustment
        if (heightAdjustment !== 0 && !this.isClimbing && !digging) { // only adjust if not climbing
            if (this.y - heightAdjustment >= 0) {
                this.y += heightAdjustment; // move sprite up (HUMAN comment: gravity takes care of down)
            } else {
                this.isDead = true;
                return;
            }
        }

        // Check if this is a Bomber, and if so create a hole
        // TODO: Need to make nearby aliens die...
        if (this.action === "Bomber") {
            createHole(this.x, this.y + this.height);
            this.isDead = true;
            return;
        }

        // HUMAN: this if block to slow down when digging
        // HUMAN: tweaked to include basher here
        if (this.actionStarted && (this.action === "Basher" || this.action === "Miner")) {
            this.velX = (this.velX > 0 ? this.maxVelX * DIGGER_SPEED_FACTOR : -this.maxVelX * DIGGER_SPEED_FACTOR);
        } else if (this.actionStarted && this.action === "Digger") {
            this.velX = 0;
            this.velY = this.maxVelX * DIGGER_SPEED_FACTOR;
        } else {
            this.velX = (this.velX > 0 ? this.maxVelX : -this.maxVelX);
        }

        // Move the lemming
        if(this.action !== "Blocker" && !this.actionStarted) {
          this.x += this.velX;
        }
        this.y += this.velY;
        this.age++;
    }
  }
}

// =========================================================================
// Digger/Basher/Miner code
// >>> Prompt: ./instructions/digger-miner-basher.0001.txt

const DIGGER_LOOK_AHEAD = 4;
const DIGGER_SPEED_FACTOR = 0.4;    // HUMAN: Changed my mind; changed from 0.2

function startDigging(lemming)
{
  switch(lemming.action) {
    case "Basher":
      return bash(lemming);
    case "Digger":
      return dig(lemming);
    case "Miner":
      return mine(lemming);
  }

  return false;
}

// >>> Prompt: ./instructions/digger-miner-basher.0001.txt
function bash(lemming)
{
  if(!lemming.onGround) {
    return false;
  }

  const x = Math.round(lemming.x);
  const y = Math.round(lemming.y);
  const vx = Math.round(lemming.velX);
  const vy = Math.round(lemming.velY);

  let pixelsDug = 0, startX, facingX, facingY, prevDugX, prevDugY;

  // HUMAN: Cheat. I tried conveying the entire concept that it might not have moved, but came up short.
  //        The easy way out here would be to ask for a very narrow prompt to write the 'previouslyDug'
  //        code below, but that felt like a cheat too. One day all cheats will llemmingd. One day.
  if(!lemming.previouslyDugAt) {
    lemming.totalDug = 0;
    lemming.previouslyDugAt = {
      x : null,
      y : null,
      dug : null
    }
  }

  prevDugX = lemming.previouslyDugAt.x;
  prevDugY = lemming.previouslyDugAt.y;

  if(lemming.velX > 0) {
    facingX = x + lemming.width + vx + DIGGER_LOOK_AHEAD;
    facingY = y + (lemming.height/2);
    startX = x;
  } else if(lemming.velX < 0) {
    facingX = x;
    facingY = y + (lemming.height/2);
    startX = x - vx - DIGGER_LOOK_AHEAD;
  }

  if(isColorOneOf(getPixelColor(oldImgData, facingX, facingY), dirtColorBytes)) {
    for(let i = 0; i < lemming.height + 1; i++) {
      for(let j = startX - 1; j < facingX; j++) {
        if(isColorOneOf(getPixelColor(oldImgData, j, y + i), dirtColorBytes)) {
          clearPixel(j, y + i);
          pixelsDug++;
          lemming.actionStarted = true;
        }
      }
    }

    if(pixelsDug > 0) {
      prevDugX = x;
      prevDugY = y;
      lemming.previouslyDugAt.x = x;
      lemming.previouslyDugAt.y = y;
      lemming.previouslyDugAt.dug = pixelsDug;
      lemming.totalDug += pixelsDug;
    }
  }

  // If lemming has not moved to a new location, recall how much was dug originally.
  if(prevDugX === x && prevDugY === y) {
    pixelsDug = lemming.previouslyDugAt.dug;
  }

  if(lemming.actionStarted && !pixelsDug) {
    console.log(lemming.action, lemming.id, "done after removing", lemming.totalDug, "pixels");    // HUMAN
    lemming.action = null;
    lemming.actionStarted = false;
    lemming.previouslyDugAt = null;
  }
  
  return pixelsDug > 0;
}


// >>> Prompt: instructions/digger.0001.txt
// HUMAN: Cheat. A lot of the logic in here was largely hand-written. :/
function dig(lemming)
{
  const x = Math.round(lemming.x);
  const y = Math.round(lemming.y);
  const vx = Math.round(lemming.velX);
  const vy = Math.round(lemming.velY);

  if(!lemming.actionStarted && !lemming.onGround) {
    return false;
  }

  let pixelsDug = 0, startY, facingX, facingY, prevDugX, prevDugY;

  // initialize previously dug values if not present already
  if (!lemming.previouslyDugAt) {
    lemming.totalDug = 0;
    lemming.previouslyDugAt = { x: null, y: null, dug: null };
  }

  prevDugX = lemming.previouslyDugAt.x;
  prevDugY = lemming.previouslyDugAt.y;

  facingY = y + lemming.height + Math.ceil(DIGGER_LOOK_AHEAD/2);
  facingX = x + (lemming.width / 2);
  startY = y + lemming.height - vy - DIGGER_LOOK_AHEAD;

  for (let i = -1; i < lemming.width + 1; i++) {
    for (let j = startY - 1; j < facingY; j++) {
      if (isColorOneOf(getPixelColor(oldImgData, x + i, j), dirtColorBytes)) {
        clearPixel(x + i, j);
        pixelsDug++;
        lemming.actionStarted = true;
      }
    }
  }

  if (pixelsDug > 0) {
    lemming.velX = 0;
    prevDugX = x;
    prevDugY = y;
    lemming.previouslyDugAt.x = x;
    lemming.previouslyDugAt.y = y;
    lemming.previouslyDugAt.dug = pixelsDug;
    lemming.totalDug += pixelsDug;
  }

  // If lemming has not moved to a new location, recall how much was dug originally.
  if (prevDugX === x && prevDugY === y) {
    pixelsDug = lemming.previouslyDugAt.dug;
  }

  if (lemming.actionStarted && !pixelsDug) {
    console.log(lemming.action, lemming.id, "done after removing", lemming.totalDug, "pixels");  // HUMAN
    lemming.action = null;
    lemming.actionStarted = false;
    lemming.velX = lemming.maxVelX;
    lemming.previouslyDugAt = null;
    return false;
  }

  return pixelsDug > 0;
}


// HUMAN: Copy of bash with minor human tweaks below
function mine(lemming)
{
  if(!lemming.onGround) {
    return false;
  }

  const x = Math.round(lemming.x);
  const y = Math.round(lemming.y);
  const vx = Math.round(lemming.velX);
  const vy = Math.round(lemming.velY);

  let pixelsDug = 0, startX, facingX, facingY, prevDugX, prevDugY;

  if(!lemming.previouslyDugAt) {
    lemming.totalDug = 0;
    lemming.previouslyDugAt = {
      x : null,
      y : null,
      dug : null
    }
  }

  prevDugX = lemming.previouslyDugAt.x;
  prevDugY = lemming.previouslyDugAt.y;

  if(lemming.velX > 0) {
    facingX = x + lemming.width + vx + DIGGER_LOOK_AHEAD;
    facingY = y + lemming.height + 1;
    startX = x;
  } else if(lemming.velX < 0) {
    facingX = x;
    facingY = y + lemming.height + 1;
    startX = x - vx - DIGGER_LOOK_AHEAD;
  }

  if(isColorOneOf(getPixelColor(oldImgData, facingX, facingY), dirtColorBytes)) {
    for(let i = 0; i < lemming.height + 2; i++) {
      for(let j = startX - 1; j < facingX; j++) {
        if(isColorOneOf(getPixelColor(oldImgData, j, y + i), dirtColorBytes)) {
          clearPixel(j, y + i);
          pixelsDug++;
          lemming.actionStarted = true;
        }
      }
    }

    if(pixelsDug > 0) {
      prevDugX = x;
      prevDugY = y;
      lemming.previouslyDugAt.x = x;
      lemming.previouslyDugAt.y = y;
      lemming.previouslyDugAt.dug = pixelsDug;
      lemming.totalDug += pixelsDug;
    }
  }

  // If lemming has not moved to a new location, recall how much was dug originally.
  if(prevDugX === x && prevDugY === y) {
    pixelsDug = lemming.previouslyDugAt.dug;
  }

  if(lemming.actionStarted && !pixelsDug) {
    console.log(lemming.action, lemming.id, "done after removing", lemming.totalDug, "pixels");    // HUMAN
    lemming.action = null;
    lemming.actionStarted = false;
  }
  
  return pixelsDug > 0;
}

// === /Digger/Basher/Miner code
// =========================================================================



// >>> Prompt: instructions/bomber.0002.txt
// HUMAN: This hole sucks, but well, at least it's a hole. And well, there's a lot of things going wrong here. It's a bad prompt apparently.
function createHole(x, y) {
  var holeSize = 50;
  var rands = [];

  x = Math.floor(x);
  y = Math.floor(y);
        
  
  // Clear pixels in background and oldImgData arrays
  for (var yOffset = -holeSize/2; yOffset < holeSize/2; yOffset++) {
    for (var xOffset = -holeSize/2; xOffset < holeSize/2; xOffset++) {
      var xCoord = x + xOffset;
      var yCoord = y + yOffset
      
      if (xCoord >= 0 && xCoord < canvas.width && yCoord >= 0 && yCoord < canvas.height) {
        var noiseValue = 255;
        var alpha = Math.round(noiseValue * 255);
        
        // Set r, g, b, and a channels of pixel
        background.data[(yCoord * canvas.width + xCoord) * 4] = 0;
        background.data[(yCoord * canvas.width + xCoord) * 4 + 1] = 0;
        background.data[(yCoord * canvas.width + xCoord) * 4 + 2] = 0;
        background.data[(yCoord * canvas.width + xCoord) * 4 + 3] = alpha;

        oldImgData.data[(yCoord * canvas.width + xCoord) * 4] = 0;
        oldImgData.data[(yCoord * canvas.width + xCoord) * 4 + 1] = 0;
        oldImgData.data[(yCoord * canvas.width + xCoord) * 4 + 2] = 0;
        oldImgData.data[(yCoord * canvas.width + xCoord) * 4 + 3] = alpha;
      }
    }
  }
}


// Create a new lemming and add it to the array of lemmings
function spawnLemming() {
  if(isPaused)
    return;
  if(lemmings.length > 15) {
    return;
  }

  const newLemming = new Lemming(); //Object.create(Lemming);
  newLemming.id = ++lastLemmingId;
  newLemming.x = Math.random() * canvas.width; // Start at a random x location
  newLemming.y = 0;
  newLemming.velX = newLemming.maxVelX; // Walk to the right by default

  //if(newLemming.id % 2) {
  if(newLemming.id === 1 || newLemming.id === 5) {
    newLemming.action = "Climber";
    console.log("Making new lemming a", newLemming.action, newLemming);
  }

  if(newLemming.id === 2) {
    newLemming.action = "Basher";
    console.log("Making new lemming a", newLemming.action, newLemming);
  }

  if(newLemming.id === 3) {
    newLemming.action = "Miner";
    console.log("Making new lemming a", newLemming.action, newLemming);
  }

  if(newLemming.id === 4) {
    newLemming.action = "Digger";
    console.log("Making new lemming a", newLemming.action, newLemming);
  }

  if(newLemming.id === 6) {
    newLemming.action = "Blocker";
    console.log("Making new lemming a", newLemming.action, newLemming);
  }
  
  lemmings.push(newLemming);
}

// Spawn a new lemming every second
setInterval(spawnLemming, 100);


let particles = [];


let isPaused = false;

// >>> Prompt: instructions/main-loop.0002.txt
function togglePause()
{
  isPaused = !isPaused;

  lemmings.forEach((lemming) => {
    console.log(
        lemming,
        getPixelColor(oldImgData, lemming.x + lemming.width / 2, lemming.y + lemming.height)
    );
  });
}


// >>> Prompt: instructions/main-loop.0001.txt
function update() {
  if (isPaused) {
    requestAnimationFrame(update);
    return;
  }
  // Restore the background
  ctx.putImageData(background, 0, 0);

  // Update and draw each lemming
  lemmings.forEach((lemming) => {
    lemming.update();
    lemming.draw();
    
    if (lemming.isDead) {
      // Remove dead lemmings from the array as optimization
      const index = lemmings.indexOf(lemming);
      lemmings.splice(index, 1);
      console.log("removing dead lemming");
      for(let i = 0; i < 50; i++) {
        // I cheated and added this color variation myself. :/ 
        const p = new Particle(lemming.x + Math.random() * 20 - 10, lemming.y + Math.random() * 20 - 10);
        p.color = i < 20 ? "#55ff55" : "#5555ff";
        particles.push(p);
      }

    }
  });
  particles.forEach((particle) => {
      particle.update();
      particle.draw();

      // Remove dead particles from the array
      if (particle.life <= 0) {
        const index = particles.indexOf(particle);
        particles.splice(index, 1);
      }
    });

  // Schedule the next frame
  requestAnimationFrame(update);
}

getBackground();

// Start the update loop
update();


// >>> Prompt: instructions/particle-explosion.0001.txt
function Particle(x, y) {
  this.x = x;
  this.y = y;
  this.velX = (Math.random() - 0.5) * 4; // Random horizontal velocity
  this.velY = -Math.random() * 6; // Random upward velocity
  this.life = 60; // Number of frames this particle should exist for
  this.color = "#FFA500"; // Orange color
}

Particle.prototype.update = function() {
  // Update position based on velocity
  this.x += this.velX;
  this.y += this.velY;

  // Apply gravity
  this.velY += 0.15;

  // Decrease life counter
  this.life--;

  // Fade out as life approaches zero
  if (this.life <= 0) {
    this.color = "#00000000"; // Transparent color
  }
};

Particle.prototype.draw = function() {
  // Draw a small rectangle at the particle's location
  ctx.fillStyle = this.color;
  ctx.fillRect(this.x, this.y, 2, 2);
};


// >>> Prompt: instructions/selectable.0001.txt
// add this after declaring canvas and ctx
canvas.addEventListener('click', (event) => {
  const rect = canvas.getBoundingClientRect();
  const mouseX = event.clientX - rect.left;
  const mouseY = event.clientY - rect.top;

  lemmings.forEach((lemming) => {
    if (
      mouseX >= lemming.x &&
      mouseX <= lemming.x + lemming.width &&
      mouseY >= lemming.y &&
      mouseY <= lemming.y + lemming.height
    ) {
      lemming.isSelected = true;
    } else {
      lemming.isSelected = false;
    }
  });
});

// >>> Prompt: instructions/actions.0001.txt

function applyAction(action) {
  // Find the selected lemming
  const selectedLemming = lemmings.find((lemming) => lemming.isSelected);

  // Note: I had to add this myself
  if(!selectedLemming) {
    console.log("no selected lemming");
    return;
  }

  // Note: I had to add this myself
  if(action !== "Bomber" && selectedLemming.action) {
    console.log("lemming already had an action");
    return;
  }
  // Apply the action to the selected lemming
  switch (action) {
    case 'Climber':
      // >>> Prompt: instructions/climber.0001.txt
      selectedLemming.action = "Climber";
      selectedLemming.isSelected = false;
      break;
    case 'Floater':
      //add floating behavior here
      // >>> Prompt: instructions/floater.0001.txt
      selectedLemming.action = "Floater";
      selectedLemming.isSelected = false;
      break;
    case 'Bomber':
      //add bombing behavior here
      // >>> Prompt: instructions/bomber.0001.txt
      selectedLemming.action = "Bomber";
      selectedLemming.isSelected = false;
      break;
    case 'Blocker':
      //add blocking behavior here
      // >>> Prompt: instructions/blocker.0001.txt
      // >>> Prompt: instructions/blocker.0002.txt
      selectedLemming.action = "Blocker";
      selectedLemming.velX = 0;
      moveOverlappingLemmingsToRandomSideOfBlocker(selectedLemming);
      selectedLemming.isSelected = false;
      break;
    case 'Builder':
      //add building behavior here
      break;
    case 'Basher':
      // >>> Prompt: ./instructions/digger-miner-basher.0001.txt
      selectedLemming.action = "Basher";     // HUMAN: Added this.
      selectedLemming.isSelected = false;
      console.log("Assigned basher to", selectedLemming.id);  // HUMAN: debug
      break;
    case 'Miner':
      // >>> Prompt: ./instructions/digger-miner-basher.0001.txt
      selectedLemming.action = "Miner";     // HUMAN: Added this.
      selectedLemming.isSelected = false;
      break;
    case 'Digger':
      // >>> Prompt: ./instructions/digger-miner-basher.0001.txt
      selectedLemming.action = "Digger";     // HUMAN: Added this.
      selectedLemming.isSelected = false;
      break;
    default:
      console.log(`Invalid action: ${action}`);
      break;
  }
}

// HUMAN: TODO: This is untested...
// >>> Prompt: instructions/blocker.0003.txt
function moveOverlappingLemmingsToRandomSideOfBlocker(blocker) {
  lemmings.forEach((lemming) => {
    if (lemming === blocker || !isColliding(lemming, blocker)) {
      return;
    }

    // determine which side of the blocker the other lemming should be on
    const side = Math.random() < 0.5 ? -1 : 1; // -1 for left side, 1 for right side

    // move the other lemming away from the blocker
    lemming.x += blocker.width / 2 * side;
  });
}

// HUMAN: helper function to check for collisions between two objects. Not entirely sure which prompt generated it.
function isColliding(obj1, obj2) {
  return obj1.x + obj1.width > obj2.x &&
         obj1.x < obj2.x + obj2.width &&
         obj1.y + obj1.height > obj2.y &&
         obj1.y < obj2.y + obj2.height;
}


function stopAction() {
  const selectedLemming = lemmings.find((lemming) => lemming.isSelected);
  if (selectedLemming) {
    selectedLemming.action = null;
    selectedLemming.isSelected = false;
  }
}

// >>> Prompt: instructions/coordinates-div.0001.txt
const coordinatesDiv = document.getElementById("coordinatesDiv");
canvas.addEventListener("mousemove", function(event) {
  const x = event.offsetX;
  const y = event.offsetY;

  const imageData = ctx.getImageData(x, y, 1, 1);
  const pixel = imageData.data;

  const color = "#" + ("000000" + rgbToHex(pixel[0], pixel[1], pixel[2])).slice(-6);

  coordinatesDiv.innerHTML = "X: " + x + ", Y: " + y + " | Color: " + color;
});


// HUMAN: this came from _one_ of the discarded Digger/Miner/Basher implementations.
// The LLM kept getting tiny parts of this wrong over and over, so I lifted this implementation
// to make it a bit easier to get something useful.
// >>> Prompt: digger-miner-basher.0001.txt
function clearPixel(x, y, col = 0) {
  if (x >= canvas.width || y >= canvas.height || x < 0 || y < 0) {
    return;
  }
  
  const pixelIndex = getPixelIndex(x, y, canvas.width);
  oldImgData.data[pixelIndex] = col;
  oldImgData.data[pixelIndex + 1] = col;
  oldImgData.data[pixelIndex + 2] = col;
  oldImgData.data[pixelIndex + 3] = 255;

  background.data[pixelIndex] = col;
  background.data[pixelIndex + 1] = col;
  background.data[pixelIndex + 2] = col;
  background.data[pixelIndex + 3] = 255;
}



// >>> Prompt: instructions/unique-colors.0001.txt
function getUniqueColors(canvas) {
  const ctx = canvas.getContext("2d");
  const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height).data;
  
  const uniqueColors = {};
  
  for (let i = 0; i < imageData.length; i += 4) {
    const r = imageData[i];
    const g = imageData[i + 1];
    const b = imageData[i + 2];

    if(!r && !g && !b) continue;  // skip background color.
    
    const colorKey = `${r},${g},${b}`;
    
    if (!uniqueColors[colorKey]) {
      uniqueColors[colorKey] = [r, g, b];
    }
  }
  
  return Object.values(uniqueColors);
}


function getPixelColor(imageData, x, y) {
    x = Math.round(x);
    y = Math.round(y);
  const index = ((y * width) + x) * 4;
  const r = imageData.data[index];
  const g = imageData.data[index + 1];
  const b = imageData.data[index + 2];
  const a = imageData.data[index + 3];

  return [r, g, b, a];
}


// >>> Prompt: instructions/pixel-is-color.0001
// >>> HUMAN CHEAT: Arrrgh. After 5-6 attempts, I give up. I rewrote the function myself! It kept omitting, 
//     e.g.: if(!Array.isArray(color[0])) { color = [ color ]; }
function pixelIsColor(imageData, x, y, color, debug) {
  x = Math.round(x);
  y = Math.round(y);
  
  const [r, g, b, alpha] = getPixelColor(imageData, x, y);

  if(r === undefined) {
    console.warn("Should not happen:", "lemming:", debug, "len:", lemmings.length, "image:", imageData, r, g, b, alpha, "x:"+x, "y:"+y, "comparing:"+color, "index:"+Math.floor((y * width + x) * 4));
    throw "This should not happen";
  }

  if(!Array.isArray(color[0])) {
    color = [ color ];
  }

  for(let i = 0; i < color.length; i++) {
    if(r === color[i][0] && g === color[i][1] && b === color[i][2]) {
      return true;
    }
  }

  return false;  
}

// >>> Prompt: instructions/get-pixel-index.0001.txt
function getPixelIndex(x, y, width) {
  x = Math.round(x);
  y = Math.round(y);

  return ((y * width) + x) * 4;
}

function isColorOneOf(needle, haystack) {
  if(!Array.isArray(haystack[0])) {       // HUMAN: Cheat. This if-block.
    return (haystack[0] === needle[0] &&
      haystack[1] === needle[1] &&
      haystack[2] === needle[2]);
  }

  for (let i = 0; i < haystack.length; i++) {
    const color = haystack[i];
    
    if (color[0] === needle[0] &&
        color[1] === needle[1] &&
        color[2] === needle[2]) {
      return true;
    }
  }
  
  return false;
}

// Returns an array containing all the color bytes for the terrain colors
function getTerrainColors() {
    return [ rockColorBytes, dirtColorBytes ];
}

// Check if given position contains any of the colors in the "haystack" array
function isPixelOneOf(imageData, x, y, haystack) {
    const needle = getPixelColor(imageData, x, y);
    return isColorOneOf(needle, haystack);
}


// >>> a helper function some implementation of Climber added
function bound(value, min, max) {
  return Math.min(Math.max(value, min), max);
}



// Remove all antialiasing so that we can easily check collisions.
// >>> Prompt: instructions/remove-terrain-smoothing.0001.txt
clearSmoothingOfTerrain(canvas, [...terrainColorBytes, waterColorBytes]);
function clearSmoothingOfTerrain(canvas, keepColors) {
  const ctx = canvas.getContext('2d');
  const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
  
  // Loop through every pixel
  for (let i = 0; i < imageData.data.length; i += 4) {
    let r = imageData.data[i];
    let g = imageData.data[i + 1];
    let b = imageData.data[i + 2];
    
    // Check if the pixel is not one of the terrain colors
    if (!keepColors.some(color => r === color[0] && g === color[1] && b === color[2])) {
      // If the pixel is not already black, set it to black
      if (r !== 0 || g !== 0 || b !== 0) {
        imageData.data[i] = 0;
        imageData.data[i + 1] = 0;
        imageData.data[i + 2] = 0;
        imageData.data[i + 3] = 255;
      }
    }
  }

  ctx.putImageData(imageData, 0, 0);
}

// >>> Prompt: instructions/coordinates-div.0001.txt
function rgbToHex(r, g, b) {
  if (r > 255 || g > 255 || b > 255)
    throw "Invalid color component";
  return ((r << 16) | (g << 8) | b).toString(16);
}
</script>

  <div id="lemming-actions">
    <button onclick="togglePause()">⏸️</button>

    <button onclick="applyAction('Climber')">🧗<!-- Climber --></button>
    <button onclick="applyAction('Floater')">🪂<!-- Floater--></button>
    <button onclick="applyAction('Bomber')">💣<!-- Bomber--></button>
    <button onclick="applyAction('Blocker')">🚫<!-- Blocker--></button>
    <button onclick="applyAction('Builder')">🏗️<!-- Builder--></button>
    <button onclick="applyAction('Basher')">🤜<!-- Basher--></button>
    <button onclick="applyAction('Miner')">⛏️<!-- Miner--></button>
    <button onclick="applyAction('Digger')">🕳️<!-- Digger--></button>
  </div>

</body>
</html>
