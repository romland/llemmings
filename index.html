<!DOCTYPE html>
<html>
<head>
    <title>Lemmings Game</title>
    <style type="text/css">
        canvas {
            border: 1px solid black;
        }
    </style>


</head>
<body>

    <canvas id="canvas" width="800" height="600"></canvas>

  

<script type="text/javascript">
// Human cheat, I needed a seedable RNG:
function RNG(seed) {
    var m = 2**35 - 31
    var a = 185852
    var s = seed % m
    return function () {
        return (s = s * a % m) / m
    }
}

// const currentSeed = Date.now();   // "random"
// const currentSeed = 1680052412448; //Date.now();     // <-- to set seed for a level
// const currentSeed = 1680052705344;
// const currentSeed = 1680055455055;
const currentSeed = 1680090362081; // Cliffy!

console.log("Current seed: ", currentSeed);
Math.random = RNG(currentSeed);

/*
Thought: I keep trying to feed errors back in, such as this:

  I get an error testing your code:
  Uncaught TypeError: points[0] is undefined

  On that line it says:
  ctx.moveTo(points[0].x, points[0].y);

It figures out what needs to be done, but it's never a simple solution... I keep
getting large code-blocks. It could however be an idea to add that type of functionality
into the "vscode gpt plugin" I am working on... We'd need to run the browser in a VSCode
controlled environment for that, though.
*/


// >>> This class was generated by ChatGPT too -- together with map generation 
// (I put it up here for convenience as this one file is getting a little unwiedly now)
class ImprovedNoise {
  constructor() {
    this.p = [];
    this.perm = [];
    this.xOff = 0;
    this.yOff = 0;
    this.zOff = 0;

    for (let i = 0; i < 256; i++) {
      this.p[i] = Math.floor(Math.random() * 256);
    }

    for (let i = 0; i < 512; i++) {
      this.perm[i] = this.p[i & 255];
    }
  }

  perlin(x, y, z) {
    const X = Math.floor(x) & 255;
    const Y = Math.floor(y) & 255;
    const Z = Math.floor(z) & 255;

    x -= Math.floor(x);
    y -= Math.floor(y);
    z -= Math.floor(z);

    const u = this.fade(x);
    const v = this.fade(y);
    const w = this.fade(z);

    const A = this.perm[X] + Y;
    const AA = this.perm[A] + Z;
    const AB = this.perm[A + 1] + Z;
    const B = this.perm[X + 1] + Y;
    const BA = this.perm[B] + Z;
    const BB = this.perm[B + 1] + Z;

    return this.lerp(
      w,
      this.lerp(v,
        this.lerp(u,
          this.grad(this.perm[AA], x, y, z),
          this.grad(this.perm[BA], x - 1, y, z)),
        this.lerp(u,
          this.grad(this.perm[AB], x, y - 1, z),
          this.grad(this.perm[BB], x - 1, y - 1, z))),
      this.lerp(v,
        this.lerp(u,
          this.grad(this.perm[AA + 1], x, y, z - 1),
          this.grad(this.perm[BA + 1], x - 1, y, z - 1)),
        this.lerp(u,
          this.grad(this.perm[AB + 1], x, y - 1, z - 1),
          this.grad(this.perm[BB + 1], x - 1, y - 1, z - 1)))
    );
  }

  grad(hash, x, y, z) {
    const h = hash & 15;
    const u = h < 8 ? x : y;
    const v = h < 4 ? y : h === 12 || h === 14 ? x : z;
    return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
  }

  fade(t) {
    return t * t * t * (t * (t * 6 - 15) + 10);
  }

  lerp(t, a, b) {
    return a + t * (b - a);
  }

  // Implementing the noise function here
  noise(x, y, z){
    // This function uses different frequency values but it can be defined as a paramenter if needed.
    const frequencyValues = [0.13, 0.16, 0.2, 0.25, 0.32, 0.4];
    
    let total = 0;
    let amplitude = 1;
    
    // Make the algorithm more flexible by accepting multiple frequency values
    for(let f of frequencyValues){
      total += this.perlin(x * f, y * f, z * f) * amplitude;
      amplitude *= 0.5; // Incremental frequency lowering.
    }

    return (total * 0.5) + 0.5; // Return a value between 0 and 1
  }
}

// HUMAN CHEAT: I moved these to top.
let background; // global variable to store canvas image data (restored in main loop below somewhere)
function getBackground() {
  background = ctx.getImageData(0, 0, canvas.width, canvas.height);
}


/*
Using plain javascript and canvas, let's create a level that looks and act like the game Lemmings. 
Specifics are:
- randomly generated textures using some noise function, the most important here is that it looks smooth and colorful
- randomly generated map using some noise function - the map should be drawn on a 960x960 canvas - it should be easy to do collision detection against the generated map.
- we want to draw the map
- need to implement all the types of lemmings (blocker, bomber, floater etc)
- we also want to make sure the lemmings automatically move and collide on the map, we want one of each type spawned on the map at start

Instead of giving me the implementation to everything right away, generate prompts I can give to you in 
portions to eventually get a full implemention. We have to do it this way because of the context window size. 
After each time you replied to a prompt, you should tell me what I should ask from you next. Also tell me what code I would need to include, if any, to get an answer.


---------------------
Like the game Lemmings, I want to procedurally generate a random map of platforms which the lemmings walk on.
The platforms are made of dirt, background color is black, here and there there should be water.
Also come up with a solution to efficiently do collision detection between lemmings and the map.

The map should be drawn on a canvas using plain javascript. Give me only the code, no explanation is needed other 
than comments in the code.
----
>>>> another Prompt:
Like the game Lemmings, I want to procedurally generate a random map of platforms which the lemmings walk on.
The platforms are layered from top to bottom and are made of dirt, the background color is black, there is 
rock here and there. At the bottom there should water.
Use perlin noise with fractal brownian motion to generate the platforms and the rock. 
Make sure that we have some continuous platforms and not a map filled with randomness.

I'll draw an example map in ASCII:
|------------------------------------------|
|                  ####          ####      |
|  ================######       #######  # |
|                              ############|
|   ###      =========================#####|
|   ####                        ###########|
|   ####              =========== #########|
|   ####                           ########|
|   ###      =======================#######|
| ######                             ##### |
|%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%|

% is blue water
# is gray rock
| and - is canvas border
= is brown dirt platform

Just because the ASCII map is all squares, does not mean the elements of the map should be. In fact, the
map should look organic, mountainy and rough.

The API for the noise generator looks like this:
    const noiseGenerator = new ImprovedNoise();
    const noiseValue = noiseGenerator.noise(x * noiseScale * frequency, 0, 0) * 0.5 + 0.5;

The map should be drawn on a canvas using plain client-side javascript. Give me only the code, no explanation is needed other 
than comments in the code.


>>> Thought, ask GPT how it would go about describing how to draw a steep mountain like cliff top on a 2D canvas in one color

>>>> Another prompt (BUT I eventually gave up on this one -- there were too many things that could go wrong): 
Update the map generation below to not only give me platforms, but add steep cliff
walls here and there, these walls should only be placed on top of platforms and should have
a bit of randomly generated jagged edges. The cliff walls should be blue (0000ff), for now.
The cliff walls can be up to 3 platforms high. The cliff wall can be at a steepness of between
70-110 degrees, but it must still be a little jagged (jaggedness should be configurable), so
you can use the number as an approximate to convey the idea. Both sides of the cliff should
go upwards toward a peak. Each cliff wall must be between 40 and 100 pixels wide. The bottom
of the cliff can be flat as it is always resting on a platform. The polygon you use to draw
the cliff must be filled (not just an outline).

Note that we still want to keep the existing rock and dirt platforms, they are good as they are,
don't change them. Just add the cliff walls on top of them.

You might be best off splitting the generation of platforms and cliff-walls into two separate
sections as you keep on messing up your line-drawing.

Just give me the code, no need to explain anything, I just want to paste in the whole thing
with the cliff-wall solution in it. The cliffs must be separated by at least 100 pixels on the X axis.

// Set canvas dimensions and context
const canvas = document.querySelector('canvas');
canvas.width = 800;
canvas.height = 600;
const ctx = canvas.getContext('2d');

// Set constants for noise generation
const noiseGenerator = new ImprovedNoise();
let noiseScale = 0.15; // (hillyness) adjust this to change the amount of detail in the noise
const frequency = 2.5;

// Set constants for map generation
const numPlatforms = 10; // adjust this to change the number of platforms
const platformHeight = canvas.height / numPlatforms;
const maxPlatformWidth = canvas.width * 0.5; // adjust this to change maximum platform width
const minPlatformWidth = canvas.width * 0.2; // adjust this to change minimum platform width
const rockProbability = 0.3; // adjust this to change the chance of generating rocks
const waterColor = '#0077be';
const rockColor = '#888888';
const dirtColor = '#4a2e00';

// Generate list of platforms
const platforms = [];
for (let i = 0; i < numPlatforms; i++) {
  const halfWidth = (Math.random() * (maxPlatformWidth - minPlatformWidth) + minPlatformWidth) / 2;
  const x = Math.random() * (canvas.width - halfWidth * 2) + halfWidth;
  const y = (i * platformHeight + platformHeight / 2) + platformHeight;     // add platformHeight so we don't have one at the very top
  platforms.push({x, y, halfWidth});
}

function drawMap() {
  // Create gradient for background color
  const grd = ctx.createLinearGradient(0, 0, 0, canvas.height);
  grd.addColorStop(0, '#111111');
  grd.addColorStop(1, '#444444');
  ctx.fillStyle = grd;
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // Draw water at bottom of canvas
  ctx.fillStyle = waterColor;
  ctx.fillRect(0, canvas.height - platformHeight, canvas.width, platformHeight);
  
  // Generate map using Perlin noise
  for (let i = platforms.length - 1; i >= 0; i--) {
    const platform = platforms[i];
    
    // Generate noise values for each pixel on the platform
    ctx.beginPath();
    ctx.moveTo(platform.x - platform.halfWidth, platform.y);
    for (let x = platform.x - platform.halfWidth; x <= platform.x + platform.halfWidth; x++) {
      const noiseValue = noiseGenerator.noise(x * noiseScale * frequency, 0, 0) * 0.5 + 0.5;
      const height = platform.y - noiseValue * platformHeight / 1.5;    // platform height divisor
      
      // Determine whether to draw dirt or rock based on probability
      if (Math.random() < rockProbability) {
        ctx.fillStyle = rockColor;
      } else {
        ctx.fillStyle = dirtColor;
      }
      ctx.lineTo(x, height);
    }
    ctx.lineTo(platform.x + platform.halfWidth, platform.y);
    ctx.closePath();
    ctx.fill();
  }
}

// call drawMap function to generate map
drawMap();

=======================================================================================================

>>>>>> Next attempt at prompt:
Update the map generation below to not only give me platforms, but add steep cliff
walls here and there, these walls should only be placed on top of platforms and should have
a bit of randomly generated jagged edges. The cliff walls can be quite tall (a few platforms high)
and take up quite a bit of width (make this configurable). The cliff walls should not be symmetrical,
as that looks a bit silly and artificial. Make them look organic (procedural, random). Their peaks 
should also only extend upwards, never downwards as the cliff base should be the platform they are
placed on. The cliff base must always be flat.

The cliff walls should be blue (0000ff), for now.

You can picture the cliff walls like this (illustration as ASCII art):

   ./\   /\
   |  \./  \
   /   \    \
   """"""""""

or

/\..
""

or

 ./\
 /  \.
/    \
""""""
or
 |\.
.| \.
 |  \
 /   \
 """"""

etc. 

They should look a bit jagged and randomly placed but the base of the walls must always be on top of a platform,
however, no cliffs must be drawn on the top 50 pixels of the canvas.

The code for generating the platforms is below, finish the drawCliffs method to add these cliff walls.

Just give me the new code, no need to explain anything, I just want to paste your new version of drawCliffs in.


// Set canvas dimensions and context
const canvas = document.querySelector('canvas');
canvas.width = 800;
canvas.height = 600;
const ctx = canvas.getContext('2d');

// Set constants for noise generation
const noiseGenerator = new ImprovedNoise();
let noiseScale = 0.15; // (hillyness) adjust this to change the amount of detail in the noise
const frequency = 2.5;

// Set constants for map generation
const numPlatforms = 10; // adjust this to change the number of platforms
const platformHeight = canvas.height / numPlatforms;
const maxPlatformWidth = canvas.width * 0.5; // adjust this to change maximum platform width
const minPlatformWidth = canvas.width * 0.2; // adjust this to change minimum platform width
const rockProbability = 0.3; // adjust this to change the chance of generating rocks
const waterColor = '#0077be';
const rockColor = '#888888';
const dirtColor = '#4a2e00';

// Generate list of platforms
const platforms = [];
for (let i = 0; i < numPlatforms; i++) {
  const halfWidth = (Math.random() * (maxPlatformWidth - minPlatformWidth) + minPlatformWidth) / 2;
  const x = Math.random() * (canvas.width - halfWidth * 2) + halfWidth;
  const y = (i * platformHeight + platformHeight / 2) + platformHeight;     // add platformHeight so we don't have one at the very top
  platforms.push({x, y, halfWidth});
}

function drawMap() {
  // Create gradient for background color
  const grd = ctx.createLinearGradient(0, 0, 0, canvas.height);
  grd.addColorStop(0, '#111111');
  grd.addColorStop(1, '#444444');
  ctx.fillStyle = grd;
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // Draw water at bottom of canvas
  ctx.fillStyle = waterColor;
  ctx.fillRect(0, canvas.height - platformHeight, canvas.width, platformHeight);
  
  // Generate map using Perlin noise
  for (let i = platforms.length - 1; i >= 0; i--) {
    const platform = platforms[i];
    
    // Generate noise values for each pixel on the platform
    ctx.beginPath();
    ctx.moveTo(platform.x - platform.halfWidth, platform.y);
    for (let x = platform.x - platform.halfWidth; x <= platform.x + platform.halfWidth; x++) {
      const noiseValue = noiseGenerator.noise(x * noiseScale * frequency, 0, 0) * 0.5 + 0.5;
      const height = platform.y - noiseValue * platformHeight / 1.5;    // platform height divisor
      
      // Determine whether to draw dirt or rock based on probability
      if (Math.random() < rockProbability) {
        ctx.fillStyle = rockColor;
      } else {
        ctx.fillStyle = dirtColor;
      }
      ctx.lineTo(x, height);
    }
    ctx.lineTo(platform.x + platform.halfWidth, platform.y);
    ctx.closePath();
    ctx.fill();
  }
}

function drawCliffs() {
  platforms.forEach((platform) => {      
    // ...
  });
}


// call drawMap function to generate map
drawMap();
drawCliffs();
*/
// Set canvas dimensions and context
const canvas = document.querySelector('canvas');
canvas.width = 800;
canvas.height = 600;
const ctx = canvas.getContext('2d');

// Set constants for noise generation
const noiseGenerator = new ImprovedNoise();
let noiseScale = 0.15; // (hillyness) adjust this to change the amount of detail in the noise
const frequency = 2.5;

// Set constants for map generation
const numPlatforms = 10; // adjust this to change the number of platforms
const platformHeight = canvas.height / numPlatforms;
const maxPlatformWidth = canvas.width * 0.5; // adjust this to change maximum platform width
const minPlatformWidth = canvas.width * 0.2; // adjust this to change minimum platform width
const rockProbability = 0.3; // adjust this to change the chance of generating rocks
const waterColor = '#0077be';
const rockColor = '#888888';
const dirtColor = '#4a2e00';

// Generate list of platforms
const platforms = [];
for (let i = 0; i < numPlatforms; i++) {
  const halfWidth = (Math.random() * (maxPlatformWidth - minPlatformWidth) + minPlatformWidth) / 2;
  const x = Math.random() * (canvas.width - halfWidth * 2) + halfWidth;
  const y = (i * platformHeight + platformHeight / 2) + platformHeight;     // add platformHeight so we don't have one at the very top
  platforms.push({x, y, halfWidth});
}

function drawMap() {
  if(false) {
    // Create gradient for background color
    const grd = ctx.createLinearGradient(0, 0, 0, canvas.height);
    grd.addColorStop(0, '#111111');
    grd.addColorStop(1, '#444444');
    ctx.fillStyle = grd;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
  } else {
    // plain black background    
    ctx.fillStyle = "#000000";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
  }
  // Draw water at bottom of canvas
  ctx.fillStyle = waterColor;
  ctx.fillRect(0, canvas.height - platformHeight, canvas.width, platformHeight);
  
  // Generate map using Perlin noise
  for (let i = platforms.length - 1; i >= 0; i--) {
    const platform = platforms[i];
    
    // Generate noise values for each pixel on the platform
    ctx.beginPath();
    ctx.moveTo(platform.x - platform.halfWidth, platform.y);
    for (let x = platform.x - platform.halfWidth; x <= platform.x + platform.halfWidth; x++) {
      const noiseValue = noiseGenerator.noise(x * noiseScale * frequency, 0, 0) * 0.5 + 0.5;
      const height = platform.y - noiseValue * platformHeight / 1.5;    // platform height divisor
      
      // Determine whether to draw dirt or rock based on probability
      if (Math.random() < rockProbability) {
        ctx.fillStyle = rockColor;
      } else {
        ctx.fillStyle = dirtColor;
      }
      platform.color = ctx.fillStyle;

      ctx.lineTo(x, height);
    }
    ctx.lineTo(platform.x + platform.halfWidth, platform.y);
    ctx.closePath();
    ctx.fill();
  }
}

function drawCliffs() {
  const cliffWidth = 100; // The width of the cliff

  platforms.forEach((platform) => {
    let addCliffRight = true;
    let addCliffLeft = true;

    // Check if there is platform to the right/left and closer than the cliff width
    for (let i = 0; i < platforms.length; i++) {
      if (i !== platforms.indexOf(platform)) {
        if (platforms[i].x - platform.x > 0 && platforms[i].x - platform.x < cliffWidth * 2) {
          addCliffRight = false;
        } else if (platforms[i].x - platform.x < 0 && platforms[i].x - platform.x > -cliffWidth * 2) {
          addCliffLeft = false;
        }
      }
    }

    // Human hack: I want cliffs to test 'climber' on
    addCliffRight = true;
    addCliffLeft = true;


    // Draw a cliff to the right and/or left of the platform
    if (addCliffRight) {
      const x = platform.x + platform.halfWidth;
      const y = platform.y - platformHeight;
      ctx.beginPath();
      ctx.moveTo(x, y);

      // Add jagged edges to cliff top
      let prevPoint = [x, y];
      for (let i = 1; i <= cliffWidth / 10; i++) {
        const nextPoint = [x + i * 10, y + Math.random() * platformHeight / 2];
        const cp1 = [prevPoint[0] + 5, prevPoint[1]];
        const cp2 = [nextPoint[0] - 5, nextPoint[1]];
        ctx.bezierCurveTo(cp1[0], cp1[1], cp2[0], cp2[1], nextPoint[0], nextPoint[1]);
        prevPoint = nextPoint;
      }

      ctx.lineTo(x + cliffWidth, platform.y);
      ctx.lineTo(x, platform.y);
      ctx.closePath();
      ctx.fillStyle = platform.color;//"#0000ff";
      ctx.fill();
    }
    if (addCliffLeft) {
      const x = platform.x - platform.halfWidth;
      const y = platform.y - platformHeight;
      ctx.beginPath();
      ctx.moveTo(x, y);

      // Add jagged edges to cliff top
      let prevPoint = [x, y];
      for (let i = 1; i <= cliffWidth / 10; i++) {
        const nextPoint = [x - i * 10, y + Math.random() * platformHeight / 2];
        const cp1 = [prevPoint[0] - 5, prevPoint[1]];
        const cp2 = [nextPoint[0] + 5, nextPoint[1]];
        ctx.bezierCurveTo(cp1[0], cp1[1], cp2[0], cp2[1], nextPoint[0], nextPoint[1]);
        prevPoint = nextPoint;
      }

      ctx.lineTo(x - cliffWidth, platform.y);
      ctx.lineTo(x, platform.y);
      ctx.closePath();
      ctx.fillStyle = platform.color;//"#0000ff";
      ctx.fill();
    }
  });
}


// call drawMap function to generate map
drawMap();
drawCliffs();

// Was just a debug test:
// console.log("Unique colors after map gen:", getUniqueColors(canvas));

/*
>>>> prompt: Give me a function that give me all unique colors on a canvas, call it getUniqueColors(canvas)
*/
function getUniqueColors(canvas) {
  const ctx = canvas.getContext("2d");
  const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height).data;
  
  const uniqueColors = {};
  
  for (let i = 0; i < imageData.length; i += 4) {
    const r = imageData[i];
    const g = imageData[i + 1];
    const b = imageData[i + 2];

    if(!r && !g && !b) continue;  // skip background color.
    
    const colorKey = `${r},${g},${b}`;
    
    if (!uniqueColors[colorKey]) {
      uniqueColors[colorKey] = [r, g, b];
    }
  }
  
  return Object.values(uniqueColors);
}


// =============== texture
/*
>>> Sadly I forgot to save the prompt for generating the "textures". :/


*/

noiseScale = 0.05; // controls zoom level
const numOctaves = 4;
const persistence = 0.5; // controls roughness
const width = canvas.width;
const height = canvas.height;

// Create a blank image to draw onto (HUMAN: actually, copy existing image ...)
let oldImgData = ctx.getImageData(0,0,width,height);    // TODO: This should be renamed, but I don't want to do it now since it would make some prompts invalid (for demonstration purposes). It does nicely illustrate the example of the need to keep track of these things.
let canvasBytes = Uint8ClampedArray.from(oldImgData.data);
const imgData = new ImageData(canvasBytes, width, height);

function getPixelColor(imageData, x, y) {
    x = Math.round(x);
    y = Math.round(y);
  const index = ((y * width) + x) * 4;
  const r = imageData.data[index];
  const g = imageData.data[index + 1];
  const b = imageData.data[index + 2];
  const a = imageData.data[index + 3];

  return [r, g, b, a];
}


/*
>>>> NEW Prompt:
Rewrite this function so that I can pass in multiple colors in the color argument, note how 'color' is already an array.
So, valid arguments would be:
[ 0xff, 0xff, 0xff ] or [[ 0xff, 0xff, 0xff ], [0xee, 0xee, 0xee]], ...

Use getPixelColor(imageData, x, y) to get the color of the pixel in the data.

function pixelIsColor(imageData, x, y, color, debug) {
    x = Math.round(x);
    y = Math.round(y);
  
  const [r, g, b, alpha] = getPixelColor(imageData, x, y);

  // if(r === undefined) {
  //   console.warn("Should not happen:", "lemming:", debug, "len:", lemmings.length, "image:", imageData, r, g, b, alpha, "x:"+x, "y:"+y, "comparing:"+color, "index:"+Math.floor((y * width + x) * 4));
  //   debug.draw();
  //   throw "This should not happen"
  // }

  return r === color[0] && g === color[1] && b === color[2];
}

>>>>> HUMAN CHEAT: Arrrgh. After 5-6 attempts, I give up. I rewrote the function myself! It kept omitting, e.g.: if(!Array.isArray(color[0])) { color = [ color ]; }
*/
function pixelIsColor(imageData, x, y, color, debug) {
  x = Math.round(x);
  y = Math.round(y);
  
  const [r, g, b, alpha] = getPixelColor(imageData, x, y);

  if(r === undefined) {
    console.warn("Should not happen:", "lemming:", debug, "len:", lemmings.length, "image:", imageData, r, g, b, alpha, "x:"+x, "y:"+y, "comparing:"+color, "index:"+Math.floor((y * width + x) * 4));
    throw "This should not happen";
  }

  if(!Array.isArray(color[0])) {
    color = [ color ];
  }

  for(let i = 0; i < color.length; i++) {
    if(r === color[i][0] && g === color[i][1] && b === color[i][2]) {
      return true;
    }
  }

  return false;  
}



/*
>>> prompt
Given this example:
function getPixelColor(imageData, x, y) {
    x = Math.round(x);
    y = Math.round(y);
  const index = ((y * width) + x) * 4;
  const r = imageData.data[index];
  const g = imageData.data[index + 1];
  const b = imageData.data[index + 2];
  const a = imageData.data[index + 3];

  return [r, g, b, a];
}

Give me the function called getPixelIndex 
*/
function getPixelIndex(x, y, width) {
  x = Math.round(x);
  y = Math.round(y);

  return ((y * width) + x) * 4;
}


if(false) {

    // Loop over each pixel in the image
    for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
        const pixelOffset = ((y * width) + x) * 4; // x2 for RGBA channels

        const isRock = pixelIsColor(imgData, x, y, [0x88, 0x88, 0x88, 255]);
        const isDirt = pixelIsColor(imgData, x, y, [0x4a, 0x2e, 0x00, 255]);

        if(!isRock && !isDirt) {
            // console.log("skipping");
            continue;
        }


        // Calculate value of noise at this pixel
        let noiseValue = 0;
        for (let octave = 1; octave <= numOctaves; octave++) {
        const frequency = Math.pow(2, octave);
        const amplitude = Math.pow(persistence, octave);
        noiseValue += noiseGenerator.noise(x * noiseScale * frequency,
                                            y * noiseScale * frequency,
                                            0) * amplitude;
        }
        noiseValue = (noiseValue * 0.5) + 0.5; // normalise between 0 and 1

        // Use noise value to determine pixel color
        let r, g, b;
        if (isRock) { // rock color
        const shade = noiseValue + (Math.random() * 0.2);
        r = shade * 90;
        g = shade * 90;
        b = shade * 90;
        } else { // dirt color
        const shade = noiseValue + (Math.random() * 0.2) - 0.4;
        r = shade * 120;
        g = shade * 100;
        b = shade * 80;
        }

        // Set the pixel color in the image data buffer
        imgData.data[pixelOffset] = r;   // Red channel
        imgData.data[pixelOffset+1] = g; // Green channel
        imgData.data[pixelOffset+2] = b; // Blue channel
        imgData.data[pixelOffset+3] = 255; // Alpha channel (255 for opaque)
    }
    }

    // Draw final image to canvas
    ctx.putImageData(imgData, 0, 0);

}

// ============== lemming sprite
/*
>>> New prompt for collision detection and lemming movement.

We are making a game like Lemmings, there is existing code.

The following are the relevant bits and are already declared in the program:
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
variable oldImgData is all pixel data gotten with ctx.getImageData()
function pixelIsColor(imageData, x, y, color): used to get compare a color of a pixel, x and y is canvas coorindate 
function getPixelColor(imageData, x, y) is used to get the color of a pixel, x and y is canvas coorindate 

The colors of various pixels are already declared:
waterColor = '#0077be';
rockColor = '#888888';
dirtColor = '#4a2e00';

The pixelIsColor() and getPixelColor() take an array of the four color components as the color argument. Figure it out.
Declare NEW constants for the colors as bytes like this: for e.g. waterColor; const waterColorBytes = [0x00, 0x77, 0xbe] ...

Using the above:
Do pixel perfect collision detection for a sprite that looks like a blue lemming with green hair 
(a blue box and a green box, basically), give it its own structure with position, velocity, etc.

It should move around on a 2d canvas which has gravity (that is, when there is no ground under it, 
it should fall down). If it runs in to an obstacle on the x axis (or the edge of the canvas) it should
turn around and walk the other way. The ground (dirt and rock) can be a bit hilly,
so there should be some fuzziness in the collision, it only stops when it runs into a tall obstacle.
If it falls into something on the y axis it should stop failling and start walking on the x axis.
If it falls into the water or went outside of canvas, the lemming is dead. Remember to check against
canvas bounds so that we don't try to get pixel data that does not exist.

Updates should be done every frame. There will eventually be many lemmings, so do note that they are
not controlled by keys, they move by themselves and is constrained by the collision rules outlined above.

It is important that you use the declared things I mentioned above. Just give me the code with
minor comments and be brief, don't explain anything with plain text.
*/

/*
Thought: It could be interesting to ask "There is already a lot of existing functionality; which bits of the existing program do you need to know about to implement the following:"
...or so
*/

/*
>>>>> New prompt: we need to make it so that a lemming adjusts on Y axis when it moves on X axis (it's hilly!)

In a game, given the below update function of a sprite walking on ground. The sprite should adjust
itself on the Y axis automatically (both up and down) as it is a bit hilly ground. Right now it just walks in a straight
line. Note that the ground underneath can be either dirt or rock. 

I don't need explanation of the code, I need you to fix the code.

*/

function isColorOneOf(needle, haystack) {
  for (let i = 0; i < haystack.length; i++) {
    const color = haystack[i];
    
    if (color[0] === needle[0] &&
        color[1] === needle[1] &&
        color[2] === needle[2]) {
      return true;
    }
  }
  
  return false;
}

// >>> a helper function some implementation of Climber wanted
function bound(value, min, max) {
  return Math.min(Math.max(value, min), max);
}


const blueBox = [0x00, 0x00, 0xff];
const greenBox = [0x00, 0xff, 0x00];
const GRAVITY = 0.03; // Adjust this until falling looks good
const lemmings = [];

const waterColorBytes = [0x00, 0x77, 0xbe]; // [0, 119, 190];
const rockColorBytes  = [0x88, 0x88, 0x88]; // [136, 136, 136];
const dirtColorBytes  = [0x4a, 0x2e, 0x00]; // [74, 46, 0];

const terrainColorBytes = [ rockColorBytes, dirtColorBytes ];

const VEL_CLIMB = 1;    // Cheat. HUMAN added this undeclared variable.

let lastLemmingId = 0;

const Lemming = {
  id: -49152,
  age: 0,
  x: 0,
  y: 0,
  width: 10,
  height: 20,
  velX: 0,
  velY: 0,
  maxVelX: 0.2,
  deadlyVelY: 3,
  isSelected: false,
  onGround: false,
  isClimbing: false,
  isDead: false,
  action: null,
  /*
  >>>> new prompt
Rewrite this whole method to make sure we do not attempt to check pixels that are out of bounds of the canvas:
Make sure to check bounds so that e.g. getPixelIndex() does not attempt to get out of bounds
pixels either.
(and then the full update() method was passed in)
  */
  update: function() {
    if (this.y >= canvas.height - (this.height + this.velY + 1)) {
      this.isDead = true;
      return;
    }

    // Check if ground is under us or not
    let isGroundUnderneath =
      pixelIsColor(oldImgData, this.x + this.width / 2, this.y + this.height + 1, dirtColorBytes) ||
      pixelIsColor(oldImgData, this.x + this.width / 2, this.y + this.height + 1, rockColorBytes);

    let heightAdjustment = 0;

    if (isGroundUnderneath) {
      let distanceToGround = -(this.height / 4);

      while (
        this.y + distanceToGround + 1 >= 0 &&
        this.y + distanceToGround + 1 < canvas.height &&
        !pixelIsColor(
          oldImgData,
          this.x + this.width / 2,
          this.y + distanceToGround + 1,
          dirtColorBytes
        ) &&
        !pixelIsColor(
          oldImgData,
          this.x + this.width / 2,
          this.y + distanceToGround + 1,
          rockColorBytes
        )
      ) {
        distanceToGround++;
      }

      if (distanceToGround !== 0) {
        heightAdjustment = this.height - distanceToGround + 0.1; // subtract half the sprite's height
      }
    }

    // Check if we hit a wall on the x axis
    const hitWallOnLeft = pixelIsColor(oldImgData, this.x - 1, this.y + this.height / 2, dirtColorBytes) ||
                          pixelIsColor(oldImgData, this.x - 1, this.y + this.height / 2, rockColorBytes);
    const hitWallOnRight =
      pixelIsColor(oldImgData, this.x + this.width + 1, this.y + this.height / 2, dirtColorBytes) ||
      pixelIsColor(oldImgData, this.x + this.width + 1, this.y + this.height / 2, rockColorBytes);

    // Check if we've fallen in water
    const isWaterBelow = pixelIsColor(oldImgData, this.x + this.width / 2, this.y + this.height + 1, waterColorBytes);

    // Determine if the lemming should climb
    let shouldClimb = false;
    if (this.action === "Climber" ) {
      if ((hitWallOnLeft && this.velX < 0) || (hitWallOnRight && this.velX > 0)) {
        shouldClimb = true;
      } else {
        this.isClimbing = false; // Reset climbing flag
      }
    }

    // Update velocity according to the collision rules
    if (!this.onGround) {
      if (this.action === "Floater") {
        this.velY += GRAVITY * 0.1;
      } else {
        this.velY += GRAVITY;
      }

      if (isGroundUnderneath) {
        if (this.velY > this.deadlyVelY) {
          // splat
          this.isDead = true;
          return;
        }
        this.onGround = true;
        this.velY = 0;
      }
    } else if (this.onGround && !isGroundUnderneath) {
      // Start falling if there's no ground
      this.onGround = false;
    }

    // Check if there are other lemmings that are blockers
    for (let i = 0; i < lemmings.length; i++) {
      const otherLemming = lemmings[i];

      if (
        otherLemming !== this &&
        !otherLemming.isDead &&
        otherLemming.action === "Blocker" &&
        this.x + this.width > otherLemming.x &&
        this.x < otherLemming.x + otherLemming.width &&
        this.y + this.height > otherLemming.y &&
        this.y < otherLemming.y + otherLemming.height
      ) {
        console.log("Ran into a blocker?", this.x, this.y);
        this.velX *= -1;
      }
    }

    // Handle climbing
    if (shouldClimb) {
      this.isClimbing = true;
      let climbDirection = hitWallOnLeft ? 1 : -1;
      this.x += climbDirection * this.maxVelX;
      this.y -= 1;

      this.velY = -VEL_CLIMB*0.05; // Start going up at climbing velocity
      this.onGround = false; // We've left the ground
    } else {
      // Not climbing, normal movement applies
      // HUMAN CHEAT: I added check for 'this.velY === 0' here so that we don't turn when we are falling
      if (this.velY === 0 && this.action !== "Climber" && (hitWallOnLeft || hitWallOnRight || this.x <= this.width || this.x >= canvas.width - this.width)) {
        this.velX *= -1;
      }

      if (isWaterBelow || this.y >= canvas.height - this.height) {
        this.isDead = true;
      }

      // Apply height adjustment
      if (heightAdjustment !== 0 && !this.isClimbing) { // only adjust if not climbing
        if (this.y - heightAdjustment >= 0) {
          this.y -= heightAdjustment; // move sprite up
        } else {
          this.isDead = true;
          return;
        }
      }

      // Check if this is a Bomber, and if so create a hole
      // TODO: Need to make nearby aliens die...
      if (this.action === "Bomber") {
        createHole(this.x, this.y + this.height);   // HUMAN CHEAT: I added + this.height
        this.isDead = true;     // HUMAN cheat: I had to add "isDead" flag :/
        return;
      }

      // Move the lemming
      this.x += this.velX;
      this.y += this.velY;
      this.age++;
    }
  },
  draw: function() {
    // Draw the new lemming position
    ctx.fillStyle = 'rgb(' + blueBox.join(',') + ')';
    ctx.fillRect(this.x, this.y, this.width, this.height);

    ctx.fillStyle = 'rgb(' + greenBox.join(',') + ')';
    ctx.fillRect(this.x, this.y, (this.width/3) - 1, (this.height/4) - 1);
    ctx.fillRect(this.x + this.width - (this.width/3), this.y, (this.width/3) - 1, (this.height/4) - 1);

    // add this to the draw method of the Lemming object
    if (this.isSelected) {
      ctx.strokeStyle = 'red';
      ctx.strokeRect(this.x, this.y, this.width, this.height);
    }

    // Debug
    ctx.strokeStyle = "white";
    ctx.strokeText(this.id, this.x + 1, this.y + 13)
  }
};


/*
let oldImgData = ctx.getImageData(0,0,width,height);    // TODO: This should be renamed, but I don't want to do it now since it would make some prompts invalid (for demonstration purposes). It does nicely illustrate the example of the need to keep track of these things.
let canvasBytes = Uint8ClampedArray.from(oldImgData.data);
const imgData = new ImageData(canvasBytes, width, height);
*/
// >>>> Note, original prompt for the creating Bomber action gave us a simpler version of this.
/*
>>> NEW PROMPT: and we need to now make it work... it even hallucinated and called oldImgData newImgData ... hmm
On a byte representation of a canvas (RGBA), given an x and y position, an explosion creates a hole. It clears
all pixels (set them to black) in an area of say 50 by 50 pixels. The edges of the hole should look a bit rough
and random, a bit spikey even -- not just a plain circle.

At your disposal you have a perlin noise class that is global called 'noiseGenerator'.
It can be used like this, for example:
noiseValue = noiseGenerator.noise(x * noiseScale * frequency, 0, 0) * 0.5 + 0.5;

You can't use any canvas drawing methods because we only have arrays, so use direct pixel manipulation on the data 
that you can get with getBackground() which got its data from this: ctx.putImageData(background, ...).
You can get to the width and height of the data by using the global variables canvas.width and canvas.height.

Since the hole will affect collisions, you also need to clear the same pixels in oldImgData which is
also originally from ctx.putImageData(oldImgData...).

Don't use any local variables called oldImageData or newImageData as that is very confusing since there are global variables
with similar names. (that you picked, I might add)

If you want to go fancy, you only update the area that needs updating instead of the entire canvas.

Make it a function like this: createHole(x, y, holeSize = 50). I don't need any explanations, just code.
Note that the x/y that are passed in might be doubles, make them ints.
*/
// HUMAN NOTE: This hole sucks, but well, at least it's a hole. And well, there's a lot of things going wrong here. It's a bad prompt apparently.
function createHole(x, y) {
  var holeSize = 50;
  var rands = [];

  x = Math.floor(x);
  y = Math.floor(y);
        
  
  // Clear pixels in background and oldImgData arrays
  for (var yOffset = -holeSize/2; yOffset < holeSize/2; yOffset++) {
    for (var xOffset = -holeSize/2; xOffset < holeSize/2; xOffset++) {
      var xCoord = x + xOffset;
      var yCoord = y + yOffset
      
      if (xCoord >= 0 && xCoord < canvas.width && yCoord >= 0 && yCoord < canvas.height) {
        // Determine pixel color based on perlin noise
        var noiseValue = noiseGenerator.noise(xCoord * noiseScale * frequency, yCoord * noiseScale * frequency, 0) * 0.5 + 0.5;
        var alpha = Math.round(noiseValue * 255);
        
        // Set r, g, b, and a channels of pixel
        background.data[(yCoord * canvas.width + xCoord) * 4] = 0;
        background.data[(yCoord * canvas.width + xCoord) * 4 + 1] = 0;
        background.data[(yCoord * canvas.width + xCoord) * 4 + 2] = 0;
        background.data[(yCoord * canvas.width + xCoord) * 4 + 3] = alpha;

        oldImgData.data[(yCoord * canvas.width + xCoord) * 4] = 0;
        oldImgData.data[(yCoord * canvas.width + xCoord) * 4 + 1] = 0;
        oldImgData.data[(yCoord * canvas.width + xCoord) * 4 + 2] = 0;
        oldImgData.data[(yCoord * canvas.width + xCoord) * 4 + 3] = alpha;
      }
    }
  }
  
  // Update only the affected region of the canvas
  ctx.putImageData(background, x - holeSize/2, y - holeSize/2, x - holeSize/2, y - holeSize/2, holeSize, holeSize);
  ctx.putImageData(oldImgData, x - holeSize/2, y - holeSize/2, x - holeSize/2, y - holeSize/2, holeSize, holeSize);
}




// Create a new lemming and add it to the array of lemmings
function spawnLemming() {
  if(isPaused)
    return;
  if(lemmings.length > 5) {
    return;
  }

  const newLemming = Object.create(Lemming);
  newLemming.id = ++lastLemmingId;
  newLemming.x = Math.random() * canvas.width; // Start at a random x location
  newLemming.y = 0;
//   newLemming.y = Math.random() * canvas.height / 4;
  newLemming.velX = newLemming.maxVelX; // Walk to the right by default

  //if(newLemming.id % 2) {
  if(newLemming.id === 1 || newLemming.id === 5) {
    console.log("Making new lemming a climber: ", newLemming);
    newLemming.action = "Climber";
  }

  lemmings.push(newLemming);
}


// Spawn a new lemming every second
// throw "arrr stop -- fix save/restore background"
setInterval(spawnLemming, 100);

/*
>>> New prompt to fix: We don't want to clear entire context, just draw and restore what was changed (the lemming)

We're making a game (Lemmings), to optmize the drawing, I want to change something...

Instead of clearing entire canvas every frame and redrawing it, just redraw the lemming that moved.
Before the lemming was drawn, it needs to keep track of the background and restore that. Make sure
we do not get any memory leaks around keeping track of the previous background.

A lemming structure looks like this:
const lemming = {
  id: -49152,
  x: 0,
  y: 0,
  width: 20,
  height: 20,
  velX: 0,
  velY: 0,
  onGround: false,
  isDead: false,
  update: function () {  Do NOT change this function  }
  draw: function() {
    // Draw the blue box and green hair
    ctx.fillStyle = 'rgb(' + blueBox.join(',') + ')';
    ctx.fillRect(this.x, this.y, this.width, this.height);
    ctx.fillStyle = 'rgb(' + greenBox.join(',') + ')';
    ctx.fillRect(this.x, this.y, 5, 5);
    ctx.fillRect(this.x + 15, this.y, 5, 5);
  }
}

And the frame update currently looks like this:
function update() {
   ctx.clearRect(0, 0, canvas.width, canvas.height);
  
  // Update and draw each lemming
  lemmings.forEach((lemming) => {
    lemming.update();
    lemming.draw();
    
    if (lemming.isDead) {
      // Remove dead lemmings from the array as optimization
      const index = lemmings.indexOf(lemming);
      lemmings.splice(index, 1);
      console.log("removing dead lemming");
    }
  });
  
  // Schedule the next frame
  requestAnimationFrame(update);
}

These variables are already declared, use them.
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

Do not use ctx.save() and ctx.restore() (you don't understand what they do). In essence, what you 
want to do is save the pixel data before you draw a lemming. Next frame you want to restore that, 
then draw the lemming at its new position. You probably should do all saving/restoring for all lemmings 
in one pass, then draw all lemmings. To avoid getting lemmings that move part of the background.
You may NOT change the lemming.update() method. 

It is important that you use the declared things I mentioned above and just give me the code with
minor comments -- be brief, don't explain anything in plain text.

==============
>>>>>>>>> VERSION 2 -- I had trouble making it understand that it should only update partial blocks -- so do entire canvas...
==============

Instead of clearing entire canvas every frame, make sure we draw back the background, and then the 
lemmings on top of that. Fix this method:

function update() {
   ctx.clearRect(0, 0, canvas.width, canvas.height);
  
  // Update and draw each lemming
  lemmings.forEach((lemming) => {
    lemming.update();
    lemming.draw();
    
    if (lemming.isDead) {
      // Remove dead lemmings from the array as optimization
      const index = lemmings.indexOf(lemming);
      lemmings.splice(index, 1);
      console.log("removing dead lemming");
    }
  });
  // Schedule the next frame
  requestAnimationFrame(update);
}

Also tell me how I should get the background data before we get to our first update.
*/

/*
>>>>>> add a pause function on mouse click in the update function
update() code went here
*/

let isPaused = false;

function togglePause()
{
  isPaused = !isPaused;

  lemmings.forEach((lemming) => {
    console.log(
        lemming,
        getPixelColor(oldImgData, lemming.x + lemming.width / 2, lemming.y + lemming.height)
    );
  });
}

/*
canvas.addEventListener('click', () => {
  togglePause();
});
*/
let particles = [];

function update() {
  if (isPaused) {
    requestAnimationFrame(update);
    return;
  }
  // Restore the background
  ctx.putImageData(background, 0, 0);

  // Update and draw each lemming
  lemmings.forEach((lemming) => {
    lemming.update();
    lemming.draw();
    
    if (lemming.isDead) {
      // Remove dead lemmings from the array as optimization
      const index = lemmings.indexOf(lemming);
      lemmings.splice(index, 1);
      console.log("removing dead lemming");
      for(let i = 0; i < 50; i++) {
        // I cheated and added this color variation myself. :/ 
        const p = new Particle(lemming.x + Math.random() * 20 - 10, lemming.y + Math.random() * 20 - 10);
        p.color = i < 20 ? "#55ff55" : "#5555ff";
        particles.push(p);
      }

    }
  });
  particles.forEach((particle) => {
      particle.update();
      particle.draw();

      // Remove dead particles from the array
      if (particle.life <= 0) {
        const index = particles.indexOf(particle);
        particles.splice(index, 1);
      }
    });

  // Schedule the next frame
  requestAnimationFrame(update);
}

getBackground();

// Start the update loop
update();


/*
>>>> add an explosion when the lemming dies

We're making a game. Given the following update loop:

function update() {
  if (isPaused) {
    requestAnimationFrame(update);
    return;
  }
  // Restore the background
  ctx.putImageData(background, 0, 0);

  // Update and draw each lemming
  lemmings.forEach((lemming) => {
    lemming.update();
    lemming.draw();
    
    if (lemming.isDead) {
      // Remove dead lemmings from the array as optimization
      const index = lemmings.indexOf(lemming);
      lemmings.splice(index, 1);
      console.log("removing dead lemming");
    }
  });

  // Schedule the next frame
  requestAnimationFrame(update);
}

And a Lemming that looks like this:

const Lemming = {
  id: -49152,
  age: 0,
  x: 0,
  y: 0,
  width: 10,
  height: 20,
  velX: 0,
  velY: 0,
  maxVelX: 0.2,
  deadlyVelY: 3.5,
  onGround: false,
  isDead: false,
  update: function() { ... }
  draw: function() { ... }
}

Additionally, the following is already declared in the game:
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

When the lemming dies, there should be a small explosion of like 50 pixels flying up like fireworks
in the location it died. Make sure that the explosion is completely disconnected from the lemming
since it should be removed from the array when it dies. Essentially, we want some kind of particle
management.
*/

function Particle(x, y) {
  this.x = x;
  this.y = y;
  this.velX = (Math.random() - 0.5) * 4; // Random horizontal velocity
  this.velY = -Math.random() * 6; // Random upward velocity
  this.life = 60; // Number of frames this particle should exist for
  this.color = "#FFA500"; // Orange color
}

Particle.prototype.update = function() {
  // Update position based on velocity
  this.x += this.velX;
  this.y += this.velY;

  // Apply gravity
  this.velY += 0.15;

  // Decrease life counter
  this.life--;

  // Fade out as life approaches zero
  if (this.life <= 0) {
    this.color = "#00000000"; // Transparent color
  }
};

Particle.prototype.draw = function() {
  // Draw a small rectangle at the particle's location
  ctx.fillStyle = this.color;
  ctx.fillRect(this.x, this.y, 2, 2);
};

/*
>>>> I want lemmings selectable so I can apply actions to them...

We're making a game. I need to add something.

Given lemmings that looks like this
const Lemming = {
  id: -49152,
  age: 0,
  x: 0,
  y: 0,
  width: 10,
  height: 20,
  velX: 0,
  velY: 0,
  maxVelX: 0.2,
  deadlyVelY: 3.5,
  onGround: false,
  isDead: false,
  update: function() { ... }
  draw: function() { ... }
}

Additionally, the following is already declared in the game:
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");


The lemmings are drawn on the canvas, I want to be able to select them to eventually apply an action
to them, for instance "stop walking". You can add that action, but know that I will add more actions
later. Indicate with a square around the lemming that is currently selected.

It is important that you use the declared things I mentioned above and just give me the code with
minor comments -- be brief, don't explain anything in plain text.
*/
// add this after declaring canvas and ctx
canvas.addEventListener('click', (event) => {
  const rect = canvas.getBoundingClientRect();
  const mouseX = event.clientX - rect.left;
  const mouseY = event.clientY - rect.top;

  lemmings.forEach((lemming) => {
    if (
      mouseX >= lemming.x &&
      mouseX <= lemming.x + lemming.width &&
      mouseY >= lemming.y &&
      mouseY <= lemming.y + lemming.height
    ) {
      lemming.isSelected = true;
    } else {
      lemming.isSelected = false;
    }
  });
});

/*
>>>> Let's use ChatGPT to describe our actions first:
What type of lemmings were there in the game Lemmings?

>>>> we want actions
Great. Using our newly selected lemming, we now want some actions we can apply to that lemming.
Perhaps buttons for these actions should be in plain HTML instead of on the canvas.

The following existing code might be useful:

const Lemming = {
  id: -49152,
  age: 0,
  x: 0,
  y: 0,
  width: 10,
  height: 20,
  velX: 0,
  velY: 0,
  maxVelX: 0.2,
  deadlyVelY: 3,
  isSelected: false,
  onGround: false,
  isDead: false,
  update: function() {
    if(this.y >= (canvas.height - (this.height+this.velY+1))) {
        this.isDead = true;
        return;
    }

    // Check if ground is under us or not
    let isGroundUnderneath = pixelIsColor(oldImgData, this.x + this.width / 2, this.y + this.height + 1, dirtColorBytes) || 
                            pixelIsColor(oldImgData, this.x + this.width / 2, this.y + this.height + 1, rockColorBytes);

    let heightAdjustment = 0;

    if (isGroundUnderneath) {
        let distanceToGround = -(this.height/4);

        // TODO need safety guards for canvas boundary and probably a sanity check to not iterate more than N pixels (N = height?)
        while (!pixelIsColor(oldImgData, this.x + this.width / 2, this.y + distanceToGround + 1, dirtColorBytes)
            && !pixelIsColor(oldImgData, this.x + this.width / 2, this.y + distanceToGround + 1, rockColorBytes)) {
            distanceToGround++;
        }
        if(distanceToGround !== 0)
          heightAdjustment = (this.height) - distanceToGround + 0.1; // subtract half the sprite's height
    }

    // Check if we hit a wall on the x axis
    const hitWallOnLeft =
        pixelIsColor(oldImgData, this.x - 1, this.y + this.height / 2, dirtColorBytes) ||
        pixelIsColor(oldImgData, this.x - 1, this.y + this.height / 2, rockColorBytes);
    const hitWallOnRight =
        pixelIsColor(oldImgData, this.x + this.width + 1, this.y + this.height / 2, dirtColorBytes) ||
        pixelIsColor(oldImgData, this.x + this.width + 1, this.y + this.height / 2, rockColorBytes); 
    
    // Check if we've fallen in water
    const isWaterBelow =
        pixelIsColor(oldImgData, this.x + this.width / 2, this.y + this.height + 1, waterColorBytes);
    
    // Update velocity according to the collision rules
    if (!this.onGround) {
      this.velY += GRAVITY;
      
      if (isGroundUnderneath) {
        // console.log(this.velY);
        if(this.velY > this.deadlyVelY) {
          // splat
          this.isDead = true;
          return;
        }
        this.onGround = true;
        this.velY = 0;
      }
    } else if (this.onGround && !isGroundUnderneath) {
      // Start falling if there's no ground
      this.onGround = false;
    }
    
    if (hitWallOnLeft || hitWallOnRight || this.x <= this.width || this.x >= canvas.width-this.width) {
      this.velX *= -1;
    }
    
    if (isWaterBelow || this.y >= canvas.height-this.height) {
      this.isDead = true;
    }

    // Apply height adjustment
    if (heightAdjustment !== 0) {
        this.y -= heightAdjustment; // move sprite up
    }
    
    // Move the lemming
    this.x += this.velX;
    this.y += this.velY;
    this.age++;
  },
  draw: function() {
    // Draw the new lemming position
    ctx.fillStyle = 'rgb(' + blueBox.join(',') + ')';
    ctx.fillRect(this.x, this.y, this.width, this.height);

    ctx.fillStyle = 'rgb(' + greenBox.join(',') + ')';
    ctx.fillRect(this.x, this.y, (this.width/3) - 1, (this.height/4) - 1);
    ctx.fillRect(this.x + this.width - (this.width/3), this.y, (this.width/3) - 1, (this.height/4) - 1);

    // add this to the draw method of the Lemming object
    if (this.isSelected) {
      ctx.strokeStyle = 'red';
      ctx.strokeRect(this.x, this.y, this.width, this.height);
    }

    // Debug
    ctx.strokeStyle = "white";
    ctx.strokeText(this.id, this.x + 1, this.y + 13)
  }
};

Add actions for:
Climber: This lemming can climb vertical surfaces such as walls and cliffs.

Floater: This lemming can use a parachute-like device to float harmlessly down from high places.

Bomber: This lemming self-destructs after a short time delay, creating a hole in the ground that other lemmings may enter.

Blocker: This lemming stops moving and turns into an immovable wall, preventing other lemmings from passing through.

Builder: This lemming can create a diagonal or horizontal bridge over gaps, making it possible for other lemmings to cross.

Basher: This lemming tunnels horizontally through soft terrain such as dirt or snow, allowing others to pass.

Miner: This lemming creates a downward-sloping tunnel, making it possible for other lemmings to descend steep inclines.

Digger: This lemming digs straight down into the ground, creating a vertical pit that other lemmings may use to jump down or climb up.
*/

function applyAction(action) {
  // Find the selected lemming
  const selectedLemming = lemmings.find((lemming) => lemming.isSelected);

  // Note: I had to add this myself
  if(!selectedLemming) {
    console.log("no selected lemming");
    return;
  }

  // Note: I had to add this myself
  if(selectedLemming.action) {
    console.log("lemming already had an action");
    return;
  }
  // Apply the action to the selected lemming
  switch (action) {
    case 'Climber':
      // >>> Prompt
/*
>>> Resetting chat history -- it keeps getting confused by the Floater action. So will prefix with more context.

We are making a game with lemmings. A specific type of lemming is a Climber. A lemming that is a Climber
will climb up (but not down) steep dirt or rock obstacles. That means it should stick to either pixels on
the left or right of it. You can find out which direction a lemming is walking in by looking at velX (you really
only need to check obstacle in the direction it is walking). The surfaces they can climb is rock and dirt. You
can find out what is what by looking at pixel data in oldImgData.

It will walk like any other lemming, the only difference is that it can also ascend steeper obstacles.

When it is climbing an obstacles, move it upwards along Y axis at the same speed as it would as if
it was walking. But make sure the lemming move along the pixels it is climbing on (that is, on either side
of the lemming).

If a climber is currently climbing, we probably don't want to do the heightAdjustment as that only applies
if the lemming is walking on the ground.

As a hint, since you are struggling, you will want to put the functionality for this inside 
if(this.action === "Climber") { ... }, in the appropriate place in the update function. You will probably
also need a flag to check if a lemming is currently climbing.

To illustrate with ASCII:

                         |----------------G
S           o   c        |
-------------------------|

"S" is where the lemmings start walking
"-" is a platform (rock or dirt)
"|" is either rock or dirt too, but it's very steep and would stop a normal lemming from going further - it should climb up this obstacle at walking speed
"o" is a normal walking lemming
"c" is a Climber
"G" is the goal where the lemmings want to go

The Climber (c) in the above illustration would be able to reach the goal, but the normal lemming (o) would not, 
it would simply walk back and forth between the steep obstacle and S.

The function pixelIsColor() can take several colors in the color argument, if the pixel at x/y match either of them, the function will return true.

const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

const Lemming = {
  id: -49152,
  age: 0,
  x: 0,
  y: 0,
  width: 10,
  height: 20,
  velX: 0,
  velY: 0,
  maxVelX: 0.2,
  deadlyVelY: 3,
  isSelected: false,
  onGround: false,
  isDead: false,
  action: null,
  update: function() {
  if (this.y >= canvas.height - (this.height + this.velY + 1)) {
    this.isDead = true;
    return;
  }

  // Check if ground is under us or not
  let isGroundUnderneath =
    pixelIsColor(oldImgData, this.x + this.width / 2, this.y + this.height + 1, dirtColorBytes) ||
    pixelIsColor(oldImgData, this.x + this.width / 2, this.y + this.height + 1, rockColorBytes);

  let heightAdjustment = 0;

  if (isGroundUnderneath) {
    let distanceToGround = -(this.height / 4);

    while (
      this.y + distanceToGround + 1 >= 0 &&
      this.y + distanceToGround + 1 < canvas.height &&
      !pixelIsColor(
        oldImgData,
        this.x + this.width / 2,
        this.y + distanceToGround + 1,
        dirtColorBytes
      ) &&
      !pixelIsColor(
        oldImgData,
        this.x + this.width / 2,
        this.y + distanceToGround + 1,
        rockColorBytes
      )
    ) {
      distanceToGround++;
    }

    if (distanceToGround !== 0) {
      heightAdjustment = this.height - distanceToGround + 0.1; // subtract half the sprite's height
    }
  }

  // Check if we hit a wall on the x axis
  const hitWallOnLeft = pixelIsColor(oldImgData, this.x - 1, this.y + this.height / 2, dirtColorBytes) ||
                        pixelIsColor(oldImgData, this.x - 1, this.y + this.height / 2, rockColorBytes);
  const hitWallOnRight =
    pixelIsColor(oldImgData, this.x + this.width + 1, this.y + this.height / 2, dirtColorBytes) ||
    pixelIsColor(oldImgData, this.x + this.width + 1, this.y + this.height / 2, rockColorBytes);

  // Check if we've fallen in water
  const isWaterBelow = pixelIsColor(oldImgData, this.x + this.width / 2, this.y + this.height + 1, waterColorBytes);

  // Update velocity according to the collision rules
  if (!this.onGround) {
    if (this.action === "Floater") {
      this.velY += GRAVITY * 0.1;
    } else {
      this.velY += GRAVITY;
    }

    if (isGroundUnderneath) {
      // console.log(this.velY);
      if (this.velY > this.deadlyVelY) {
        // splat
        this.isDead = true;
        return;
      }
      this.onGround = true;
      this.velY = 0;
    }
  } else if (this.onGround && !isGroundUnderneath) {
    // Start falling if there's no ground
    this.onGround = false;
  }

  // Check if there are other lemmings that are blockers
  for (let i = 0; i < lemmings.length; i++) {
    const otherLemming = lemmings[i];

    if (
      otherLemming !== this &&
      !otherLemming.isDead &&
      otherLemming.action === "Blocker" &&
      this.x + this.width > otherLemming.x &&
      this.x < otherLemming.x + otherLemming.width &&
      this.y + this.height > otherLemming.y &&
      this.y < otherLemming.y + otherLemming.height
    ) {
      console.log("Ran into a blocker?", this.x, this.y);
      this.velX *= -1;
    }
  }

  if (
    hitWallOnLeft ||
    hitWallOnRight ||
    this.x <= this.width ||
    this.x >= canvas.width - this.width
  ) {
    this.velX *= -1;
  }

  if (isWaterBelow || this.y >= canvas.height - this.height) {
    this.isDead = true;
  }

  // Apply height adjustment
  if (heightAdjustment !== 0) {
    if (this.y - heightAdjustment >= 0) {
      this.y -= heightAdjustment; // move sprite up
    } else {
      this.isDead = true;
      return;
    }
  }

  // Move the lemming
  this.x += this.velX;
  this.y += this.velY;
  this.age++;
},
  draw: function() {
    // Draw the new lemming position
    ctx.fillStyle = 'rgb(' + blueBox.join(',') + ')';
    ctx.fillRect(this.x, this.y, this.width, this.height);

    ctx.fillStyle = 'rgb(' + greenBox.join(',') + ')';
    ctx.fillRect(this.x, this.y, (this.width/3) - 1, (this.height/4) - 1);
    ctx.fillRect(this.x + this.width - (this.width/3), this.y, (this.width/3) - 1, (this.height/4) - 1);

    // add this to the draw method of the Lemming object
    if (this.isSelected) {
      ctx.strokeStyle = 'red';
      ctx.strokeRect(this.x, this.y, this.width, this.height);
    }

    // Debug
    ctx.strokeStyle = "white";
    ctx.strokeText(this.id, this.x + 1, this.y + 13)
  }
};

I only want to change the update() function in the lemming. Show me the changed update() function, the
rest of the Lemming you don't have to give me code for.

I don't want pseudo-code, I want real code. If you use a function not mentioned above, give implementation for that.

*/
      selectedLemming.action = "Climber";
      selectedLemming.isSelected = false;
      break;
    case 'Floater':
      //add floating behavior here
      // >>> Prompt:
      // Give me the code for how the Floater action should make the lemming behave now. There is already a selected lemming, I just need the code on how the lemming should behave in its update()
      selectedLemming.action = "Floater";
      selectedLemming.isSelected = false;
      break;
    case 'Bomber':
      //add bombing behavior here
/*
>>>> Prompt
We are making a game with lemmings. A specific type of lemming is a Bomber. When a lemming is assigned to be a bomber,
it should stop moving and then blow up and create an random, organic looking hole at it's location -- the lemming will die from this. The hole
it leaves after should be carved out by clearing pixels in oldImgData.

A lemming looks like this:


Create a function that creates the hole.
I also need the logic to add to Lemming's update function.

I don't want pseudo-code, I want real code. And only code, no comments. If you need to create functions not declared
in the snippet I gave you, implement them and show them to me.

*/      
      selectedLemming.action = "Bomber";
      selectedLemming.isSelected = false;
      break;
    case 'Blocker':
      //add blocking behavior here
      /*
      >>> Prompt
      Can you give me the code for how the blocker should work?
      Remember that the other lemmings should not be able to walk past it, other lemmings should now treat the Blocker like an impenetrable wall -- remember to check whether the lemming is on the same Y as the blocker too -- you should probably check the entire collision box of the lemming instead of a single pixel.
      The Blocker itself should stop moving on the X axis.
      Only one action can be applied to a lemming.
      Deselect the lemming once an action is applied.
      Tell me what I need to add to the lemming.update() method too.

      >>>> Update to the result of the above:
      Update the code, which sits in Lemming.update(), instead of checking only a single pixel on x, it should check for two boxes colliding (lemmings),
      width, height, x, y, velX, velY are already defined in the object.
      // force other lemmings to turn around if they hit the blocker
      lemmings.forEach(otherLemming => {
        if (otherLemming !== this && !otherLemming.isDead && otherLemming.action === "Blocker") {
          if ((otherLemming.x > this.x && otherLemming.velX > 0) || 
              (otherLemming.x < this.x && otherLemming.velX < 0)) {
            otherLemming.velX *= -1;
            console.log("Ran into a blocker?", this.x, this.y)
          }
        }
      });
      Instead of forEach, use a for(...) loop. Only update the code above.

      >>> And more ...
      When the Blocker action is applied on one lemming, there might be other lemmings overlapping it, move the overlapping other lemmings to a random side of the Blocker when the action is applied. Just give me the new code.

      >>> Ugh, it got confused, let's try another prompt...
      I think I'd just rather call moveOverlappingLemmingsToRandomSideOfBlocker() Tell me how that function should look

      */
      selectedLemming.action = "Blocker";
      selectedLemming.velX = 0;
      moveOverlappingLemmingsToRandomSideOfBlocker(selectedLemming);
      selectedLemming.isSelected = false;
      break;
    case 'Builder':
      //add building behavior here
      break;
    case 'Basher':
      //add bashing behavior here
      break;
    case 'Miner':
      //add mining behavior here
      break;
    case 'Digger':
      //add digging behavior here
      break;
    default:
      console.log(`Invalid action: ${action}`);
      break;
  }
}

// TODO: This is untested...
function moveOverlappingLemmingsToRandomSideOfBlocker(blocker) {
  lemmings.forEach((lemming) => {
    if (lemming === blocker || !isColliding(lemming, blocker)) {
      return;
    }

    // determine which side of the blocker the other lemming should be on
    const side = Math.random() < 0.5 ? -1 : 1; // -1 for left side, 1 for right side

    // move the other lemming away from the blocker
    lemming.x += blocker.width / 2 * side;
  });
}
// helper function to check for collisions between two objects
function isColliding(obj1, obj2) {
  return obj1.x + obj1.width > obj2.x &&
         obj1.x < obj2.x + obj2.width &&
         obj1.y + obj1.height > obj2.y &&
         obj1.y < obj2.y + obj2.height;
}


function stopAction() {
  const selectedLemming = lemmings.find((lemming) => lemming.isSelected);
  if (selectedLemming) {
    selectedLemming.action = null;
    selectedLemming.isSelected = false;
  }
}
</script>

<!-- haha, this made me smile
>>> Can you give me some emoji's I can use for the action buttons climber, floater, etc ... it looks so dull with text
Climber: 
Floater: 
Bomber: 
Blocker: 
Builder: 
Basher: 
Miner: 
Digger: 
-->
<div id="lemming-actions">
  <button onclick="togglePause()"></button>

  <button onclick="applyAction('Climber')"><!-- Climber --></button>
  <button onclick="applyAction('Floater')"><!-- Floater--></button>
  <button onclick="applyAction('Bomber')"><!-- Bomber--></button>
  <button onclick="applyAction('Blocker')"><!-- Blocker--></button>
  <button onclick="applyAction('Builder')"><!-- Builder--></button>
  <button onclick="applyAction('Basher')"><!-- Basher--></button>
  <button onclick="applyAction('Miner')"><!-- Miner--></button>
  <button onclick="applyAction('Digger')"><!-- Digger--></button>
</div>

<style>
  button {
    font-size: 40px;
  }
</style>

</body>
</html>
