<!DOCTYPE html>
<html>
<head>
    <title>Llemmings</title>
    <style type="text/css">
        canvas {
            border: 1px solid black;
        }
        button {
          font-size: 40px;
        }

        /* >>> Prompt: css.0001.txt */
        body {
          font-family: Arial, sans-serif;
          background-color: #000;
          color: #f0f0f0;
          margin: 0;
          padding: 0;
          height: 100vh; /* set the height to 100% of the viewport height */
        }

        header {
            background-color: black;
            color: #F0F0F0;
            padding: 10px;
            text-align: center;
        }

        p {
            font-size: 16px;
            margin-top: 0;
        }

        a {
            color: #F0F0F0;
            text-decoration: none;
        }

        a:hover {
            color: grey;
        }
    </style>
</head>
<body>

<!-- >>> Prompt: instructions/about.0001.txt -->
<header>
    <p>What is this? <a href="https://github.com/romland/llemmings">See Github</a>.</p>
</header>

  <canvas id="canvas" width="800" height="600"></canvas>
  <div id="coordinatesDiv"></div>


<script type="text/javascript">
// HUMAN: cheat, I needed a seedable RNG
function RNG(seed) {
    var m = 2**35 - 31
    var a = 185852
    var s = seed % m
    return function () {
        return (s = s * a % m) / m
    }
}

// const currentSeed = Date.now();   // "random"
// const currentSeed = 1680052412448;
// const currentSeed = 1680052705344;
// const currentSeed = 1680055455055;
// const currentSeed = 1680197028534; // Cliffy!
const currentSeed = 1680397601417; // Lemming #2 (Basher) survive

console.log("Current seed: ", currentSeed);
Math.random = RNG(currentSeed);


// >>> Prompt: instructions/map-generation.0001.txt
class ImprovedNoise {
  constructor() {
    this.p = [];
    this.perm = [];
    this.xOff = 0;
    this.yOff = 0;
    this.zOff = 0;

    for (let i = 0; i < 256; i++) {
      this.p[i] = Math.floor(Math.random() * 256);
    }

    for (let i = 0; i < 512; i++) {
      this.perm[i] = this.p[i & 255];
    }
  }

  perlin(x, y, z) {
    const X = Math.floor(x) & 255;
    const Y = Math.floor(y) & 255;
    const Z = Math.floor(z) & 255;

    x -= Math.floor(x);
    y -= Math.floor(y);
    z -= Math.floor(z);

    const u = this.fade(x);
    const v = this.fade(y);
    const w = this.fade(z);

    const A = this.perm[X] + Y;
    const AA = this.perm[A] + Z;
    const AB = this.perm[A + 1] + Z;
    const B = this.perm[X + 1] + Y;
    const BA = this.perm[B] + Z;
    const BB = this.perm[B + 1] + Z;

    return this.lerp(
      w,
      this.lerp(v,
        this.lerp(u,
          this.grad(this.perm[AA], x, y, z),
          this.grad(this.perm[BA], x - 1, y, z)),
        this.lerp(u,
          this.grad(this.perm[AB], x, y - 1, z),
          this.grad(this.perm[BB], x - 1, y - 1, z))),
      this.lerp(v,
        this.lerp(u,
          this.grad(this.perm[AA + 1], x, y, z - 1),
          this.grad(this.perm[BA + 1], x - 1, y, z - 1)),
        this.lerp(u,
          this.grad(this.perm[AB + 1], x, y - 1, z - 1),
          this.grad(this.perm[BB + 1], x - 1, y - 1, z - 1)))
    );
  }

  grad(hash, x, y, z) {
    const h = hash & 15;
    const u = h < 8 ? x : y;
    const v = h < 4 ? y : h === 12 || h === 14 ? x : z;
    return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
  }

  fade(t) {
    return t * t * t * (t * (t * 6 - 15) + 10);
  }

  lerp(t, a, b) {
    return a + t * (b - a);
  }

  // Implementing the noise function here
  noise(x, y, z){
    // This function uses different frequency values but it can be defined as a paramenter if needed.
    const frequencyValues = [0.13, 0.16, 0.2, 0.25, 0.32, 0.4];
    
    let total = 0;
    let amplitude = 1;
    
    // Make the algorithm more flexible by accepting multiple frequency values
    for(let f of frequencyValues){
      total += this.perlin(x * f, y * f, z * f) * amplitude;
      amplitude *= 0.5; // Incremental frequency lowering.
    }

    return (total * 0.5) + 0.5; // Return a value between 0 and 1
  }
}

let background; // global variable to store canvas image data (restored in main loop below somewhere)
function getBackground() {
  background = ctx.getImageData(0, 0, canvas.width, canvas.height);
}


// >>> Prompt: instructions/map-generation.0001.txt
// >>> Prompt: instructions/map-generation.0002.txt
// Set canvas dimensions and context
const canvas = document.querySelector('canvas');
canvas.width = 800;
canvas.height = 600;
const ctx = canvas.getContext('2d');

// Set constants for noise generation
const noiseGenerator = new ImprovedNoise();
let noiseScale = 0.15; // (hillyness) adjust this to change the amount of detail in the noise
const frequency = 2.5;

// Set constants for map generation
const numPlatforms = 10; // adjust this to change the number of platforms
const platformHeight = canvas.height / numPlatforms;
const maxPlatformWidth = canvas.width * 0.5; // adjust this to change maximum platform width
const minPlatformWidth = canvas.width * 0.2; // adjust this to change minimum platform width
const rockProbability = 0.3; // adjust this to change the chance of generating rocks
const waterColor = '#0077be';
const rockColor = '#888888';
const dirtColor = '#4a2e00';

// Generate list of platforms
const platforms = [];
for (let i = 0; i < numPlatforms; i++) {
  const halfWidth = (Math.random() * (maxPlatformWidth - minPlatformWidth) + minPlatformWidth) / 2;
  const x = Math.random() * (canvas.width - halfWidth * 2) + halfWidth;
  const y = (i * platformHeight + platformHeight / 2) + platformHeight;     // add platformHeight so we don't have one at the very top
  platforms.push({x, y, halfWidth});
}

function drawMap() {
  if(false) {
    // Create gradient for background color
    const grd = ctx.createLinearGradient(0, 0, 0, canvas.height);
    grd.addColorStop(0, '#111111');
    grd.addColorStop(1, '#444444');
    ctx.fillStyle = grd;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
  } else {
    // plain black background    
    ctx.fillStyle = "#000000";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
  }
  // Draw water at bottom of canvas
  ctx.fillStyle = waterColor;
  ctx.fillRect(0, canvas.height - platformHeight, canvas.width, platformHeight);
  
  // Generate map using Perlin noise
  for (let i = platforms.length - 1; i >= 0; i--) {
    const platform = platforms[i];
    
    // Generate noise values for each pixel on the platform
    ctx.beginPath();
    ctx.moveTo(platform.x - platform.halfWidth, platform.y);
    for (let x = platform.x - platform.halfWidth; x <= platform.x + platform.halfWidth; x++) {
      const noiseValue = noiseGenerator.noise(x * noiseScale * frequency, 0, 0) * 0.5 + 0.5;
      const height = platform.y - noiseValue * platformHeight / 1.5;    // platform height divisor
      
      // Determine whether to draw dirt or rock based on probability
      if (Math.random() < rockProbability) {
        ctx.fillStyle = rockColor;
      } else {
        ctx.fillStyle = dirtColor;
      }
      platform.color = ctx.fillStyle;

      ctx.lineTo(x, height);
    }
    ctx.lineTo(platform.x + platform.halfWidth, platform.y);
    ctx.closePath();
    ctx.fill();
  }
}

function drawCliffs() {
  const cliffWidth = 100; // The width of the cliff

  platforms.forEach((platform) => {
    let addCliffRight = true;
    let addCliffLeft = true;

    // Check if there is platform to the right/left and closer than the cliff width
    for (let i = 0; i < platforms.length; i++) {
      if (i !== platforms.indexOf(platform)) {
        if (platforms[i].x - platform.x > 0 && platforms[i].x - platform.x < cliffWidth * 2) {
          addCliffRight = false;
        } else if (platforms[i].x - platform.x < 0 && platforms[i].x - platform.x > -cliffWidth * 2) {
          addCliffLeft = false;
        }
      }
    }

    // Human hack: I want cliffs to test 'climber' on
    addCliffRight = true;
    addCliffLeft = true;


    // Draw a cliff to the right and/or left of the platform
    if (addCliffRight) {
      const x = platform.x + platform.halfWidth - 2;      // HUMAN: 1-off fixed
      const y = platform.y - platformHeight;
      ctx.beginPath();
      ctx.moveTo(x, y);

      // Add jagged edges to cliff top
      let prevPoint = [x, y];
      for (let i = 1; i <= cliffWidth / 10; i++) {
        const nextPoint = [x + i * 10, y + Math.random() * platformHeight / 2];
        const cp1 = [prevPoint[0] + 5, prevPoint[1]];
        const cp2 = [nextPoint[0] - 5, nextPoint[1]];
        ctx.bezierCurveTo(cp1[0], cp1[1], cp2[0], cp2[1], nextPoint[0], nextPoint[1]);
        prevPoint = nextPoint;
      }

      ctx.lineTo(x + cliffWidth, platform.y);
      ctx.lineTo(x, platform.y);
      ctx.closePath();
      ctx.fillStyle = platform.color;//"#0000ff";
      ctx.fill();
    }
    if (addCliffLeft) {
      const x = platform.x - platform.halfWidth + 2;      // HUMAN: 1-off fixed
      const y = platform.y - platformHeight;
      ctx.beginPath();
      ctx.moveTo(x, y);

      // Add jagged edges to cliff top
      let prevPoint = [x, y];
      for (let i = 1; i <= cliffWidth / 10; i++) {
        const nextPoint = [x - i * 10, y + Math.random() * platformHeight / 2];
        const cp1 = [prevPoint[0] - 5, prevPoint[1]];
        const cp2 = [nextPoint[0] + 5, nextPoint[1]];
        ctx.bezierCurveTo(cp1[0], cp1[1], cp2[0], cp2[1], nextPoint[0], nextPoint[1]);
        prevPoint = nextPoint;
      }

      ctx.lineTo(x - cliffWidth, platform.y);
      ctx.lineTo(x, platform.y);
      ctx.closePath();
      ctx.fillStyle = platform.color;//"#0000ff";
      ctx.fill();
    }
  });
}


// call drawMap function to generate map
drawMap();
drawCliffs();


// >>> Prompt: instructions/unique-colors.0001.txt
function getUniqueColors(canvas) {
  const ctx = canvas.getContext("2d");
  const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height).data;
  
  const uniqueColors = {};
  
  for (let i = 0; i < imageData.length; i += 4) {
    const r = imageData[i];
    const g = imageData[i + 1];
    const b = imageData[i + 2];

    if(!r && !g && !b) continue;  // skip background color.
    
    const colorKey = `${r},${g},${b}`;
    
    if (!uniqueColors[colorKey]) {
      uniqueColors[colorKey] = [r, g, b];
    }
  }
  
  return Object.values(uniqueColors);
}


// >>> Prompt: Sadly I forgot to save the prompt for generating the "textures". :/

noiseScale = 0.05; // controls zoom level
const numOctaves = 4;
const persistence = 0.5; // controls roughness
const width = canvas.width;
const height = canvas.height;

// Create a blank image to draw onto (HUMAN: actually, copy existing image ...)
let oldImgData = ctx.getImageData(0,0,width,height);    // TODO: This should be renamed, but I don't want to do it now since it would make some prompts invalid (for demonstration purposes). It does nicely illustrate the example of the need to keep track of these things.
let canvasBytes = Uint8ClampedArray.from(oldImgData.data);
const imgData = new ImageData(canvasBytes, width, height);

function getPixelColor(imageData, x, y) {
    x = Math.round(x);
    y = Math.round(y);
  const index = ((y * width) + x) * 4;
  const r = imageData.data[index];
  const g = imageData.data[index + 1];
  const b = imageData.data[index + 2];
  const a = imageData.data[index + 3];

  return [r, g, b, a];
}


// >>> Prompt: instructions/pixel-is-color.0001
// >>> HUMAN CHEAT: Arrrgh. After 5-6 attempts, I give up. I rewrote the function myself! It kept omitting, 
//     e.g.: if(!Array.isArray(color[0])) { color = [ color ]; }
function pixelIsColor(imageData, x, y, color, debug) {
  x = Math.round(x);
  y = Math.round(y);
  
  const [r, g, b, alpha] = getPixelColor(imageData, x, y);

  if(r === undefined) {
    console.warn("Should not happen:", "lemming:", debug, "len:", lemmings.length, "image:", imageData, r, g, b, alpha, "x:"+x, "y:"+y, "comparing:"+color, "index:"+Math.floor((y * width + x) * 4));
    throw "This should not happen";
  }

  if(!Array.isArray(color[0])) {
    color = [ color ];
  }

  for(let i = 0; i < color.length; i++) {
    if(r === color[i][0] && g === color[i][1] && b === color[i][2]) {
      return true;
    }
  }

  return false;  
}


// >>> Prompt: instructions/get-pixel-index.0001.txt
function getPixelIndex(x, y, width) {
  x = Math.round(x);
  y = Math.round(y);

  return ((y * width) + x) * 4;
}


// Render "texture" (or not)
if(false) {
    // Loop over each pixel in the image
    for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
        const pixelOffset = ((y * width) + x) * 4; // x2 for RGBA channels

        const isRock = pixelIsColor(imgData, x, y, [0x88, 0x88, 0x88, 255]);
        const isDirt = pixelIsColor(imgData, x, y, [0x4a, 0x2e, 0x00, 255]);

        if(!isRock && !isDirt) {
            // console.log("skipping");
            continue;
        }


        // Calculate value of noise at this pixel
        let noiseValue = 0;
        for (let octave = 1; octave <= numOctaves; octave++) {
        const frequency = Math.pow(2, octave);
        const amplitude = Math.pow(persistence, octave);
        noiseValue += noiseGenerator.noise(x * noiseScale * frequency,
                                            y * noiseScale * frequency,
                                            0) * amplitude;
        }
        noiseValue = (noiseValue * 0.5) + 0.5; // normalise between 0 and 1

        // Use noise value to determine pixel color
        let r, g, b;
        if (isRock) { // rock color
        const shade = noiseValue + (Math.random() * 0.2);
        r = shade * 90;
        g = shade * 90;
        b = shade * 90;
        } else { // dirt color
        const shade = noiseValue + (Math.random() * 0.2) - 0.4;
        r = shade * 120;
        g = shade * 100;
        b = shade * 80;
        }

        // Set the pixel color in the image data buffer
        imgData.data[pixelOffset] = r;   // Red channel
        imgData.data[pixelOffset+1] = g; // Green channel
        imgData.data[pixelOffset+2] = b; // Blue channel
        imgData.data[pixelOffset+3] = 255; // Alpha channel (255 for opaque)
    }
    }

    // Draw final image to canvas
    ctx.putImageData(imgData, 0, 0);

}

function isColorOneOf(needle, haystack) {
  for (let i = 0; i < haystack.length; i++) {
    const color = haystack[i];
    
    if (color[0] === needle[0] &&
        color[1] === needle[1] &&
        color[2] === needle[2]) {
      return true;
    }
  }
  
  return false;
}

// Returns an array containing all the color bytes for the terrain colors
function getTerrainColors() {
    return [ rockColorBytes, dirtColorBytes ];
}

// Check if given position contains any of the colors in the "haystack" array
function isPixelOneOf(imageData, x, y, haystack) {
    const needle = getPixelColor(imageData, x, y);
    return isColorOneOf(needle, haystack);
}


// >>> a helper function some implementation of Climber added
function bound(value, min, max) {
  return Math.min(Math.max(value, min), max);
}


const blueBox = [0x00, 0x00, 0xff];
const greenBox = [0x00, 0xff, 0x00];
const GRAVITY = 0.03; // Adjust this until falling looks good
const lemmings = [];

const waterColorBytes = [0x00, 0x77, 0xbe]; // [0, 119, 190];
const rockColorBytes  = [0x88, 0x88, 0x88]; // [136, 136, 136];
const dirtColorBytes  = [0x4a, 0x2e, 0x00]; // [74, 46, 0];

const terrainColorBytes = [ rockColorBytes, dirtColorBytes ];

const VEL_CLIMB = 1;    // Cheat. HUMAN added this undeclared variable.

let lastLemmingId = 0;

// ============== lemming sprite
// >>> Prompt: instructions/movement-collisions.0001.txt
// >>> Prompt: instructions/movement-collisions.0002.txt
// >>> Prompt: instructions/movement-collisions.0003.txt
// >>> Prompt: instructions/lemming.update.0001.txt
const Lemming = {
  id: -49152,
  age: 0,
  x: 0,
  y: 0,
  width: 10,
  height: 20,
  velX: 0,
  velY: 0,
  maxVelX: 0.2,
  deadlyVelY: 3,
  isSelected: false,
  onGround: false,
  isClimbing: false,
  isDead: false,
  action: null,
  actionStarted : false,
  update: function() {
    if (this.y >= canvas.height - (this.height + this.velY + 1)) {
        this.isDead = true;
        return;
    }

    // Check if ground is under us or not
    let isGroundUnderneath = isPixelOneOf(oldImgData, this.x + this.width / 2, this.y + this.height + 1, terrainColorBytes);

    let heightAdjustment = 0;

    if (isGroundUnderneath) {
        let distanceToGround = -(this.height / 4);

        while (this.y + distanceToGround + 1 >= 0 && this.y + distanceToGround + 1 < canvas.height &&
            !isPixelOneOf(oldImgData, this.x + this.width / 2, this.y + distanceToGround + 1, terrainColorBytes)
        ) {
            distanceToGround++;
        }

        if (distanceToGround !== 0) {
            heightAdjustment = this.height - distanceToGround + 0.1; // subtract half the sprite's height
        }
    }

    // Check if we hit a wall on the x axis
    const hitWallOnLeft = isPixelOneOf(oldImgData, this.x - 1, this.y + this.height / 2, terrainColorBytes);
    const hitWallOnRight = isPixelOneOf(oldImgData, this.x + this.width + 1, this.y + this.height / 2, terrainColorBytes);

    // Check if we've fallen in water
    const isWaterBelow = pixelIsColor(oldImgData, this.x + this.width / 2, this.y + this.height + 1, waterColorBytes);

    // Determine if the lemming should climb
    let shouldClimb = false;

    if (this.action === "Climber") {
        if ((hitWallOnLeft && this.velX < 0) || (hitWallOnRight && this.velX > 0)) {
            shouldClimb = true;
        } else {
            this.isClimbing = false; // Reset climbing flag
        }
    }

    // Update velocity according to the collision rules
    if (!this.onGround) {
        if (this.action === "Floater") {
            this.velY += GRAVITY * 0.1;
        } else {
            this.velY += GRAVITY;
        }

        if (isGroundUnderneath) {
            if (this.velY > this.deadlyVelY) {
                // splat
                this.isDead = true;
                return;
            }
            this.onGround = true;
            this.velY = 0;
        }
    } else if (this.onGround && !isGroundUnderneath) {
        // Start falling if there's no ground
        this.onGround = false;
    }

    // ============ Digger/Basher/Miner code
    let digging = false;

    if (this.action === "Digger" || this.action === "Miner" || this.action === "Basher") {
        digging = startDigging(this);
    }
    // ============ /Digger/Basher/Miner code

    // Check if there are other lemmings that are blockers
    for (let i = 0; i < lemmings.length; i++) {
        const otherLemming = lemmings[i];

        if (
            otherLemming !== this &&
            !otherLemming.isDead &&
            otherLemming.action === "Blocker" &&
            this.x + this.width > otherLemming.x &&
            this.x < otherLemming.x + otherLemming.width &&
            this.y + this.height > otherLemming.y &&
            this.y < otherLemming.y + otherLemming.height
        ) {
            console.log("Ran into a blocker?", this.x, this.y);
            this.velX *= -1;
        }
    }

    // Handle climbing
    if (shouldClimb) {
        this.isClimbing = true;
        let climbDirection = hitWallOnLeft ? 1 : -1;
        this.x += climbDirection * this.maxVelX;
        this.y -= 1;

        this.velY = -VEL_CLIMB*0.05; // Start going up at climbing velocity
        this.onGround = false; // We've left the ground
    } else {
        // Not climbing, normal movement applies
        // HUMAN: added check for 'this.velY === 0' here so that we don't turn when we are falling
        // HUMAN: don't turn if digging
        if (!digging && this.velY === 0 && this.action !== "Climber" && (hitWallOnLeft || hitWallOnRight || this.x <= this.width || this.x >= canvas.width - this.width)) {
            this.velX *= -1;
        }

        if (isWaterBelow || this.y >= canvas.height - this.height) {
            this.isDead = true;
        }

        // Apply height adjustment
        if (heightAdjustment !== 0 && !this.isClimbing && !digging) { // only adjust if not climbing
            if (this.y - heightAdjustment >= 0) {
                this.y -= heightAdjustment; // move sprite up (HUMAN comment: gravity takes care of down)
            } else {
                this.isDead = true;
                return;
            }
        }

        // Check if this is a Bomber, and if so create a hole
        // TODO: Need to make nearby aliens die...
        if (this.action === "Bomber") {
            createHole(this.x, this.y + this.height);
            this.isDead = true;
            return;
        }

        // HUMAN: this if block to slow down when digging
        if (this.actionStarted && (this.action === "Basher" || this.action === "Digger" || this.action === "Miner")) {
            this.velX = (this.velX > 0 ? this.maxVelX * DIGGER_SPEED_FACTOR : -this.maxVelX * DIGGER_SPEED_FACTOR);
        } else {
            this.velX = (this.velX > 0 ? this.maxVelX : -this.maxVelX);
        }

        // Move the lemming
        this.x += this.velX;
        this.y += this.velY;
        this.age++;
    }
  },
  draw: function() {
    // Draw the new lemming position
    ctx.fillStyle = 'rgb(' + blueBox.join(',') + ')';
    ctx.fillRect(this.x, this.y, this.width, this.height);

    ctx.fillStyle = 'rgb(' + greenBox.join(',') + ')';
    ctx.fillRect(this.x, this.y, (this.width/3) - 1, (this.height/4) - 1);
    ctx.fillRect(this.x + this.width - (this.width/3), this.y, (this.width/3) - 1, (this.height/4) - 1);

    // add this to the draw method of the Lemming object
    if (this.isSelected) {
      ctx.strokeStyle = 'red';
      ctx.strokeRect(this.x, this.y, this.width, this.height);
    }

    // Debug
    ctx.strokeStyle = "white";
    ctx.strokeText(this.id, this.x + 1, this.y + 13);
    if(this.action) {
      ctx.font = "7px Arial";
      ctx.strokeText(this.action, this.x - 5, this.y - 5);
    }
  }
};

// =========================================================================
// Digger/Basher/Miner code
// >>> Prompt: ./instructions/digger-miner-basher.0001.txt

const DIGGER_LOOK_AHEAD = 4;
const DIGGER_SPEED_FACTOR = 0.2;    // HUMAN: Changed my mind; changed from 0.2

function startDigging(lemming)
{
  if(!lemming.onGround || (lemming.action !== "Basher" && lemming.action !== "Digger" && lemming.action !== "Miner")) {
    return false;
  }

  switch(lemming.action) {
    case "Basher":
      return bash(lemming);
    case "Digger":
      return dig(lemming);
    case "Miner":
      return mine(lemming);
  }

  return false;
}

// >>> Prompt: ./instructions/digger-miner-basher.0001.txt
function bash(lemming)
{
  const x = Math.round(lemming.x);
  const y = Math.round(lemming.y);
  const vx = Math.round(lemming.velX);
  const vy = Math.round(lemming.velY);

  let pixelsDug = 0, startX, facingX, facingY;

  if(lemming.totalDug === undefined) {
    lemming.totalDug = 0;
  }

  if(lemming.velX > 0) {
    facingX = x + lemming.width + DIGGER_LOOK_AHEAD;
    facingY = y + (lemming.height/2);
    startX = x;
  } else if(lemming.velX < 0) {
    facingX = x;
    facingY = y + (lemming.height/2);
    startX = x - vx - DIGGER_LOOK_AHEAD;
  } else {
    return false;
  }

  if(!isColorOneOf(getPixelColor(oldImgData, facingX, facingY), terrainColorBytes)) {
    return false;
  }

  for(let i = 0; i < lemming.height + 1; i++) {
    for(let j = startX - 1; j < facingX; j++) {
      if(isColorOneOf(getPixelColor(oldImgData, j, y + i), terrainColorBytes)) {
        clearPixel(j, y + i);
        pixelsDug++;
        lemming.actionStarted = true;
      }
    }
  }
  lemming.totalDug += pixelsDug;

  // HUMAN: Cheat. I tried conveying the entire concept that it might not have moved, but came up short.
  //        The easy way out here would be to ask for a very narrow prompt to write the 'previouslyDug'
  //        code below, but that felt like a cheat too. One day all cheats will llemmingd. One day.
  if(lemming.previouslyDugAt && lemming.previouslyDugAt.x !== x && lemming.previouslyDugAt.y !== y
     && lemming.actionStarted && !pixelsDug) {
    console.log(lemming.action, lemming.id, "done after removing", lemming.totalDug, "pixels");    // HUMAN
    lemming.action = null;
    lemming.actionStarted = false;
  }

  lemming.previouslyDugAt = {"x":x,"y":y};
  return pixelsDug > 0;
}

// >>> Prompt: ./instructions/digger-miner-basher.0001.txt
function dig(lemming)
{
  const x = Math.round(lemming.x);
  const y = Math.round(lemming.y);
  const vx = Math.round(lemming.velX);
  const vy = Math.round(lemming.velY);

  let pixelsDug = 0, startY, facingX, facingY;

  if(lemming.totalDug === undefined) {
    lemming.totalDug = 0;
  }

  facingX = x;
  facingY = y + lemming.height + DIGGER_LOOK_AHEAD;
  startY = y + lemming.height;

  for(let i = 0; i < lemming.width; i++) {
    for(let j = startY - 1; j < facingY; j++) {
      if(isColorOneOf(getPixelColor(oldImgData, x + i, y + j), terrainColorBytes)) {
        clearPixel(i, y + j);
        pixelsDug++;
        lemming.actionStarted = true;
      }
    }
  }

  lemming.totalDug += pixelsDug;

  if(lemming.actionStarted && !pixelsDug) {
    console.log(lemming.action, lemming.id, "done after removing", lemming.totalDug, "pixels");    // HUMAN
    lemming.action = null;
    lemming.actionStarted = false;
  } else if(pixelsDug) {
    lemming.velX = 0;
  }

  return pixelsDug > 0;
}



// === /Digger/Basher/Miner code
// =========================================================================

// HUMAN: this came from _one_ of the discarded Digger/Miner/Basher implementations.
// The LLM kept getting tiny parts of this wrong over and over, so I lifted this implementation
// to make it a bit easier to get something useful.
// >>> Prompt: digger-miner-basher.0001.txt
function clearPixel(x, y) {
  if (x >= canvas.width || y >= canvas.height || x < 0 || y < 0) {
    return;
  }
  
  const pixelIndex = getPixelIndex(x, y, canvas.width);
  oldImgData.data[pixelIndex] = 0;
  oldImgData.data[pixelIndex + 1] = 0;
  oldImgData.data[pixelIndex + 2] = 0;
  oldImgData.data[pixelIndex + 3] = 255;

  background.data[pixelIndex] = 0;
  background.data[pixelIndex + 1] = 0;
  background.data[pixelIndex + 2] = 0;
  background.data[pixelIndex + 3] = 255;
}


// >>> Prompt: instructions/bomber.0002.txt
// HUMAN: This hole sucks, but well, at least it's a hole. And well, there's a lot of things going wrong here. It's a bad prompt apparently.
function createHole(x, y) {
  var holeSize = 50;
  var rands = [];

  x = Math.floor(x);
  y = Math.floor(y);
        
  
  // Clear pixels in background and oldImgData arrays
  for (var yOffset = -holeSize/2; yOffset < holeSize/2; yOffset++) {
    for (var xOffset = -holeSize/2; xOffset < holeSize/2; xOffset++) {
      var xCoord = x + xOffset;
      var yCoord = y + yOffset
      
      if (xCoord >= 0 && xCoord < canvas.width && yCoord >= 0 && yCoord < canvas.height) {
        // Determine pixel color based on perlin noise
        var noiseValue = noiseGenerator.noise(xCoord * noiseScale * frequency, yCoord * noiseScale * frequency, 0) * 0.5 + 0.5;
        var alpha = Math.round(noiseValue * 255);
        
        // Set r, g, b, and a channels of pixel
        background.data[(yCoord * canvas.width + xCoord) * 4] = 0;
        background.data[(yCoord * canvas.width + xCoord) * 4 + 1] = 0;
        background.data[(yCoord * canvas.width + xCoord) * 4 + 2] = 0;
        background.data[(yCoord * canvas.width + xCoord) * 4 + 3] = alpha;

        oldImgData.data[(yCoord * canvas.width + xCoord) * 4] = 0;
        oldImgData.data[(yCoord * canvas.width + xCoord) * 4 + 1] = 0;
        oldImgData.data[(yCoord * canvas.width + xCoord) * 4 + 2] = 0;
        oldImgData.data[(yCoord * canvas.width + xCoord) * 4 + 3] = alpha;
      }
    }
  }
}


// Create a new lemming and add it to the array of lemmings
function spawnLemming() {
  if(isPaused)
    return;
  if(lemmings.length > 5) {
    return;
  }

  const newLemming = Object.create(Lemming);
  newLemming.id = ++lastLemmingId;
  newLemming.x = Math.random() * canvas.width; // Start at a random x location
  newLemming.y = 0;
  newLemming.velX = newLemming.maxVelX; // Walk to the right by default

  //if(newLemming.id % 2) {
  if(newLemming.id === 1 || newLemming.id === 5) {
    newLemming.action = "Climber";
    console.log("Making new lemming a", newLemming.action, newLemming);
  }

  if(newLemming.id === 4) {
    newLemming.action = "Digger";
    console.log("Making new lemming a", newLemming.action, newLemming);
  }
  
  if(newLemming.id === 2) {
    newLemming.action = "Basher";
    console.log("Making new lemming a", newLemming.action, newLemming);
  }

  lemmings.push(newLemming);
}

// Spawn a new lemming every second
setInterval(spawnLemming, 100);


let particles = [];


let isPaused = false;

// >>> Prompt: instructions/main-loop.0002.txt
function togglePause()
{
  isPaused = !isPaused;

  lemmings.forEach((lemming) => {
    console.log(
        lemming,
        getPixelColor(oldImgData, lemming.x + lemming.width / 2, lemming.y + lemming.height)
    );
  });
}


// >>> Prompt: instructions/main-loop.0001.txt
function update() {
  if (isPaused) {
    requestAnimationFrame(update);
    return;
  }
  // Restore the background
  ctx.putImageData(background, 0, 0);

  // Update and draw each lemming
  lemmings.forEach((lemming) => {
    lemming.update();
    lemming.draw();
    
    if (lemming.isDead) {
      // Remove dead lemmings from the array as optimization
      const index = lemmings.indexOf(lemming);
      lemmings.splice(index, 1);
      console.log("removing dead lemming");
      for(let i = 0; i < 50; i++) {
        // I cheated and added this color variation myself. :/ 
        const p = new Particle(lemming.x + Math.random() * 20 - 10, lemming.y + Math.random() * 20 - 10);
        p.color = i < 20 ? "#55ff55" : "#5555ff";
        particles.push(p);
      }

    }
  });
  particles.forEach((particle) => {
      particle.update();
      particle.draw();

      // Remove dead particles from the array
      if (particle.life <= 0) {
        const index = particles.indexOf(particle);
        particles.splice(index, 1);
      }
    });

  // Schedule the next frame
  requestAnimationFrame(update);
}

getBackground();

// Start the update loop
update();


// >>> Prompt: instructions/particle-explosion.0001.txt
function Particle(x, y) {
  this.x = x;
  this.y = y;
  this.velX = (Math.random() - 0.5) * 4; // Random horizontal velocity
  this.velY = -Math.random() * 6; // Random upward velocity
  this.life = 60; // Number of frames this particle should exist for
  this.color = "#FFA500"; // Orange color
}

Particle.prototype.update = function() {
  // Update position based on velocity
  this.x += this.velX;
  this.y += this.velY;

  // Apply gravity
  this.velY += 0.15;

  // Decrease life counter
  this.life--;

  // Fade out as life approaches zero
  if (this.life <= 0) {
    this.color = "#00000000"; // Transparent color
  }
};

Particle.prototype.draw = function() {
  // Draw a small rectangle at the particle's location
  ctx.fillStyle = this.color;
  ctx.fillRect(this.x, this.y, 2, 2);
};


// >>> Prompt: instructions/selectable.0001.txt
// add this after declaring canvas and ctx
canvas.addEventListener('click', (event) => {
  const rect = canvas.getBoundingClientRect();
  const mouseX = event.clientX - rect.left;
  const mouseY = event.clientY - rect.top;

  lemmings.forEach((lemming) => {
    if (
      mouseX >= lemming.x &&
      mouseX <= lemming.x + lemming.width &&
      mouseY >= lemming.y &&
      mouseY <= lemming.y + lemming.height
    ) {
      lemming.isSelected = true;
    } else {
      lemming.isSelected = false;
    }
  });
});

// >>> Prompt: instructions/actions.0001.txt

function applyAction(action) {
  // Find the selected lemming
  const selectedLemming = lemmings.find((lemming) => lemming.isSelected);

  // Note: I had to add this myself
  if(!selectedLemming) {
    console.log("no selected lemming");
    return;
  }

  // Note: I had to add this myself
  if(action !== "Bomber" && selectedLemming.action) {
    console.log("lemming already had an action");
    return;
  }
  // Apply the action to the selected lemming
  switch (action) {
    case 'Climber':
      // >>> Prompt: instructions/climber.0001.txt
      selectedLemming.action = "Climber";
      selectedLemming.isSelected = false;
      break;
    case 'Floater':
      //add floating behavior here
      // >>> Prompt: instructions/floater.0001.txt
      selectedLemming.action = "Floater";
      selectedLemming.isSelected = false;
      break;
    case 'Bomber':
      //add bombing behavior here
      // >>> Prompt: instructions/bomber.0001.txt
      selectedLemming.action = "Bomber";
      selectedLemming.isSelected = false;
      break;
    case 'Blocker':
      //add blocking behavior here
      // >>> Prompt: instructions/blocker.0001.txt
      // >>> Prompt: instructions/blocker.0002.txt
      selectedLemming.action = "Blocker";
      selectedLemming.velX = 0;
      moveOverlappingLemmingsToRandomSideOfBlocker(selectedLemming);
      selectedLemming.isSelected = false;
      break;
    case 'Builder':
      //add building behavior here
      break;
    case 'Basher':
      // >>> Prompt: ./instructions/digger-miner-basher.0001.txt
      selectedLemming.action = "Basher";     // HUMAN: Added this.
      selectedLemming.isSelected = false;
      console.log("Assigned basher to", selectedLemming.id);  // HUMAN: debug
      break;
    case 'Miner':
      // >>> Prompt: ./instructions/digger-miner-basher.0001.txt
      selectedLemming.action = "Miner";     // HUMAN: Added this.
      selectedLemming.isSelected = false;
      break;
    case 'Digger':
      // >>> Prompt: ./instructions/digger-miner-basher.0001.txt
      selectedLemming.action = "Miner";     // HUMAN: Added this.
      selectedLemming.isSelected = false;
      break;
    default:
      console.log(`Invalid action: ${action}`);
      break;
  }
}

// HUMAN: TODO: This is untested...
// >>> Prompt: instructions/blocker.0003.txt
function moveOverlappingLemmingsToRandomSideOfBlocker(blocker) {
  lemmings.forEach((lemming) => {
    if (lemming === blocker || !isColliding(lemming, blocker)) {
      return;
    }

    // determine which side of the blocker the other lemming should be on
    const side = Math.random() < 0.5 ? -1 : 1; // -1 for left side, 1 for right side

    // move the other lemming away from the blocker
    lemming.x += blocker.width / 2 * side;
  });
}

// HUMAN: helper function to check for collisions between two objects. Not entirely sure which prompt generated it.
function isColliding(obj1, obj2) {
  return obj1.x + obj1.width > obj2.x &&
         obj1.x < obj2.x + obj2.width &&
         obj1.y + obj1.height > obj2.y &&
         obj1.y < obj2.y + obj2.height;
}


function stopAction() {
  const selectedLemming = lemmings.find((lemming) => lemming.isSelected);
  if (selectedLemming) {
    selectedLemming.action = null;
    selectedLemming.isSelected = false;
  }
}

// >>> Prompt: instructions/coordinates-div.0001.txt
const coordinatesDiv = document.getElementById("coordinatesDiv");
canvas.addEventListener("mousemove", function(event) {
  const x = event.offsetX;
  const y = event.offsetY;

  const imageData = ctx.getImageData(x, y, 1, 1);
  const pixel = imageData.data;

  const color = "#" + ("000000" + rgbToHex(pixel[0], pixel[1], pixel[2])).slice(-6);

  coordinatesDiv.innerHTML = "X: " + x + ", Y: " + y + " | Color: " + color;
});


// >>> Prompt: instructions/coordinates-div.0001.txt
function rgbToHex(r, g, b) {
  if (r > 255 || g > 255 || b > 255)
    throw "Invalid color component";
  return ((r << 16) | (g << 8) | b).toString(16);
}
</script>

  <div id="lemming-actions">
    <button onclick="togglePause()">⏸️</button>

    <button onclick="applyAction('Climber')">🧗<!-- Climber --></button>
    <button onclick="applyAction('Floater')">🪂<!-- Floater--></button>
    <button onclick="applyAction('Bomber')">💣<!-- Bomber--></button>
    <button onclick="applyAction('Blocker')">🚫<!-- Blocker--></button>
    <button onclick="applyAction('Builder')">🏗️<!-- Builder--></button>
    <button onclick="applyAction('Basher')">🤜💥🤛<!-- Basher--></button>
    <button onclick="applyAction('Miner')">⛏️<!-- Miner--></button>
    <button onclick="applyAction('Digger')">🕳️<!-- Digger--></button>
  </div>

</body>
</html>
